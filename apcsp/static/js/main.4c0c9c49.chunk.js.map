{"version":3,"sources":["Editor.tsx","CodeBlock.tsx","language/run.ts","RenderValue.tsx","Variables.tsx","Console.tsx","Running.tsx","language/ast.tsx","language/tokenizer.tsx","language/parser.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["Editor","code","setCode","onRun","error","className","onClick","fontSize","value","onChange","x","location","line","col","message","CodeBlock","asts","map","i","AstElement","ast","parens","AstElementWithoutError","render","subast","alwaysInParens","inParensIfOperator","parensIfAlways","parensIfOperator","renderBlock","block","React","cloneElement","key","boxList","items","content","toComponent","length","arrowOnLeft","el","running","type","lhs","rhs","isRunning","opString","operator","condition","iftrue","iffalse","times","list","index","itemvar","name","paramaters","procedure","expr","toString","Cancel","Error","Object","setPrototypeOf","prototype","ReturnException","this","Interpreter","callbacks","globals","locals","shouldCancelReal","shouldStep","annotatedAst","Map","set","builtin","call","params","a","onDisplay","cloneDeep","onWaitForInput","inputString","maybeCancel","num","Number","isNaN","push","isInteger","removed","splice","b","Math","floor","random","newValue","console","log","has","expectType","runBlock","catch","onInfo","broadcastInfo","onStepPause","evaluate","stat","step","run","assign","evaluated","n","isFirstTime","equals","isequal","result","item","undefined","get","nparams","oldLocals","valueToString","hideQuotes","res","sep","JSON","stringify","RenderValue","Variables","variables","Array","from","entries","Console","displayed","onInput","useState","input","setInput","style","color","onSubmit","e","preventDefault","autoFocus","target","Running","unAnnotated","onClose","consoleLines","setConsoleLines","interpreter","setInterpreter","annotated","setAnnotated","nextStep","setNextStep","setVariables","setOnInput","cancel","shouldCancel","newInterpreter","old","Promise","resolve","oldOnInput","interpret","then","err","operators","isLiteral","isAssignable","keywords","symbols","tokenize","remainder","match","firstToken","text","token","whitespace","slice","whitespaceMatch","exec","numberMatch","parseFloat","symbolsSorted","sort","sym","startsWith","stringMatch","parse","idMatch","keyword","find","ParseError","charAt","Parser","tokens","current","precedences","next","consume","statement","expect","accept","expression","param","isStatement","literal","minPrecToStop","primary","op","nextPrecedence","App","mode","data","setData","setError","program","href","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.4c0c9c49.chunk.js","sourcesContent":["import { ParseError } from \"./language/parser\";\r\nimport \"./Editor.css\";\r\nimport AceEditor from \"react-ace\";\r\nimport React from \"react\";\r\n\r\nexport default function Editor({ code, setCode, onRun, error }:\r\n    { code: string, setCode: (code: string) => void, onRun: () => void, error: ParseError | null }) {\r\n\r\n\r\n    return (<div className=\"Editor\">\r\n        <div className=\"toolbar\"><button onClick={() => onRun()}>Run</button></div>\r\n        <div className=\"codeErrorMessageContainer\">\r\n            <AceEditor className=\"code\" fontSize={18} value={code} onChange={(x) => setCode(x)}></AceEditor>\r\n            {error && <div className=\"errorMessage\">{error.location.line}:{error.location.col} {error.message}</div>}\r\n        </div>\r\n    </div>\r\n    )\r\n}","import { Ast, Statement } from \"./language/ast\";\r\n\r\nimport \"./CodeBlock.css\";\r\nimport React from \"react\";\r\nimport { Annotations } from \"./language/run\";\r\n\r\nexport function CodeBlock({ asts }: { asts: Statement<Annotations>[] }) {\r\n    return (<div className=\"CodeBlock\">\r\n        {asts.map((x, i) => <AstElement key={i} ast={x} />)}\r\n    </div>)\r\n}\r\n\r\nexport function AstElement({ ast, parens = \"never\" }: { ast: Ast<Annotations>, parens?: \"always\" | \"ifoperator\" | \"never\" }) {\r\n    if (ast.error) {\r\n        return <span className=\"errorContainer\">\r\n            <div className=\"errorText\">{ast.error}</div>\r\n            <span className=\"errorElement\"><AstElementWithoutError ast={ast} parens={parens} />\r\n            </span>\r\n        </span>\r\n    } else {\r\n        return <AstElementWithoutError ast={ast} parens={parens} />\r\n    }\r\n}\r\n\r\nfunction AstElementWithoutError({ ast, parens = \"never\" }: { ast: Ast<Annotations>, parens?: \"always\" | \"ifoperator\" | \"never\" }) {\r\n\r\n    const render = (subast: Ast) => <AstElement ast={subast} />\r\n\r\n    const alwaysInParens = (subast: Ast) => <AstElement ast={subast} parens=\"always\" />\r\n    const inParensIfOperator = (subast: Ast) => <AstElement ast={subast} parens=\"ifoperator\" />\r\n\r\n    const parensIfAlways = (x: JSX.Element) => {\r\n        if (parens === \"always\") {\r\n            return <span><span className=\"alt\">(</span><span className=\"oval\">{x}</span><span className=\"alt\"></span></span>\r\n        } else {\r\n            return x;\r\n        }\r\n    }\r\n    const parensIfOperator = (x: JSX.Element) => {\r\n        if (parens === \"ifoperator\" || parens === \"always\") {\r\n            return <span><span className=\"alt\">(</span><span className=\"oval\">{x}</span><span className=\"alt\"></span></span>\r\n        } else {\r\n            return x;\r\n        }\r\n    }\r\n    const renderBlock = (block: Ast[]) => (<div className=\"indentedBlock\"><span className=\"alt\">{\"{\"}</span>{block.map((x, i) => {\r\n        return React.cloneElement(render(x), { key: i })\r\n    })}<span className=\"alt\">{\"}\"}</span></div>)\r\n\r\n    // todo: &thinsp; might not be best\r\n    const boxList = (items: Ast[] | string[]) => {\r\n        const toComponent = (x: Ast | string) => {\r\n            if (typeof x === \"string\") {\r\n                return x;\r\n            } else {\r\n                return inParensIfOperator(x);\r\n            }\r\n        }\r\n        let content;\r\n        if (items.length === 0) {\r\n            content = <>&thinsp;</>\r\n        } else {\r\n            content = items.map((x, i) => <>{i > 0 && \", \"}{toComponent(x)}</>)\r\n        }\r\n        return <span className=\"box\"><span className=\"alt\">[</span>{content}<span className=\"alt\">]</span></span>;\r\n    }\r\n\r\n    const arrowOnLeft = (el: JSX.Element, running: boolean = false) => {\r\n        if (running) {\r\n            return <div className=\"running\">\r\n                <div className=\"runningArrow\">{\">\"}</div>\r\n                {el}\r\n            </div>\r\n        } else {\r\n            return el;\r\n        }\r\n    }\r\n\r\n    if (ast.type === \"assign\") {\r\n        return arrowOnLeft(<div className=\"rounded\">{render(ast.lhs)} &larr; {render(ast.rhs)}</div>, ast.isRunning);\r\n    } else if (ast.type === \"breakpoint\") {\r\n        return arrowOnLeft(<div className=\"rounded\">BREAKPOINT</div>, ast.isRunning);\r\n    }\r\n    else if (ast.type === \"operator\") {\r\n        const opString = ast.operator === \"!=\" ? \"≠\"\r\n            : ast.operator === \">=\" ? \"≥\"\r\n                : ast.operator === \"<=\" ? \"≤\"\r\n                    : ast.operator;\r\n        return parensIfOperator(<span>{inParensIfOperator(ast.lhs)} {opString} {inParensIfOperator(ast.rhs)}</span>)\r\n    }\r\n    else if (ast.type === \"not\") {\r\n        return parensIfOperator(<span>NOT {inParensIfOperator(ast.value)}</span>)\r\n    }\r\n    else if (ast.type === \"negate\") {\r\n        return parensIfOperator(<span>-{inParensIfOperator(ast.value)}</span>)\r\n    }\r\n    else if (ast.type === \"if\") {\r\n        return <div className=\"filled\">\r\n            {arrowOnLeft(<div className=\"condition\">IF {alwaysInParens(ast.condition)}</div>, ast.isRunning)}\r\n            {renderBlock(ast.iftrue)}\r\n        </div >\r\n    }\r\n    else if (ast.type === \"ifelse\") {\r\n        return <div className=\"filled\">\r\n            {arrowOnLeft(<div className=\"condition\">IF {alwaysInParens(ast.condition)}</div>, ast.isRunning)}\r\n            {renderBlock(ast.iftrue)}\r\n            <div className=\"condition\">ELSE</div>\r\n            {renderBlock(ast.iffalse)}\r\n        </div>\r\n    }\r\n    else if (ast.type === \"repeattimes\") {\r\n        return <div className=\"filled\">\r\n            {arrowOnLeft(<div className=\"condition\">REPEAT {inParensIfOperator(ast.times)} TIMES</div>, ast.isRunning)}\r\n            {renderBlock(ast.block)}\r\n        </div>\r\n    }\r\n    else if (ast.type === \"repeatuntil\") {\r\n        return <div className=\"filled\">\r\n            {arrowOnLeft(<div className=\"condition\">REPEAT UNTIL {alwaysInParens(ast.condition)}</div>, ast.isRunning)}\r\n            {renderBlock(ast.block)}\r\n        </div>\r\n    }\r\n    else if (ast.type === \"list\") {\r\n        return boxList(ast.items)\r\n    }\r\n    else if (ast.type === \"subscript\") {\r\n        return parensIfAlways(<span>{render(ast.list)}&thinsp;<span className=\"alt\">[</span><span className=\"box\">{render(ast.index)}</span><span className=\"alt\">]</span></span>)\r\n    }\r\n    else if (ast.type === \"foreach\") {\r\n        return <div className=\"filled\">\r\n            {arrowOnLeft(<div className=\"condition\">FOR EACH {inParensIfOperator(ast.itemvar)} IN {inParensIfOperator(ast.list)}</div>, ast.isRunning)}\r\n            {renderBlock(ast.block)}\r\n        </div>\r\n    }\r\n    else if (ast.type === \"procedure\") {\r\n        return <div className=\"filled\">\r\n            <div className=\"condition\">PROCEDURE {ast.name} {boxList(ast.paramaters)}</div>\r\n            {renderBlock(ast.block)}\r\n        </div>\r\n    }\r\n    else if (ast.type === \"return\") {\r\n        return arrowOnLeft(<div className=\"rounded\">RETURN <span className=\"box\">{render(ast.value)}</span></div>, ast.isRunning)\r\n    }\r\n    else if (ast.type === \"returnvoid\") {\r\n        return arrowOnLeft(<div className=\"rounded\">RETURN</div>, ast.isRunning)\r\n    }\r\n    else if (ast.type === \"call\") {\r\n        return parensIfOperator(<span>{render(ast.procedure)} {ast.paramaters.length > 0 && boxList(ast.paramaters)}</span>)\r\n    }\r\n    else if (ast.type === \"exprstat\") {\r\n        return arrowOnLeft(<div className=\"rounded\">{render(ast.expr)}</div>, ast.isRunning)\r\n    }\r\n    else if (ast.type === \"string\") {\r\n        return parensIfAlways(<span>&quot;{ast.value}&quot;</span>) // todo: fix\r\n    }\r\n    else if (ast.type === \"number\") {\r\n        return parensIfAlways(<span>{ast.value.toString()}</span>)\r\n    }\r\n    else if (ast.type === \"boolean\") {\r\n        return parensIfAlways(<span>{ast.value ? \"true\" : \"false\"}</span>)\r\n    }\r\n    else if (ast.type === \"variable\") {\r\n        return parensIfAlways(<span>{ast.name}</span>)\r\n    }\r\n    return <span>??</span>;\r\n}","import { AssignableExpression, Ast, Expression, Statement } from \"./ast\";\r\nimport cloneDeep from \"lodash.clonedeep\";\r\nimport isequal from \"lodash.isequal\";\r\n\r\nexport type Value =\r\n    | { type: \"number\", value: number }\r\n    | { type: \"string\", value: string }\r\n    | { type: \"boolean\", value: boolean }\r\n    | { type: \"list\", value: Value[] }\r\n    | { type: \"procedure\", builtin: true, call(ast: Ast<Annotations> & { type: \"call\" }, params: Value[]): Promise<Value> }\r\n    | { type: \"procedure\", builtin: false, ast: Ast<Annotations> & { type: \"procedure\" } }\r\n    | { type: \"void\" }\r\n\r\nexport type Annotations = { evaluated?: Value, isRunning?: boolean, error?: string }\r\n\r\nexport class RuntimeError extends Error {\r\n    constructor(message: string) {\r\n        super(message);\r\n        Object.setPrototypeOf(this, RuntimeError.prototype);\r\n    }\r\n}\r\n\r\nexport class Cancel extends Error {\r\n    constructor() {\r\n        super(\"we have canceled\");\r\n        Object.setPrototypeOf(this, Cancel.prototype);\r\n    }\r\n}\r\n\r\nexport class ReturnException {\r\n    ast: Ast<Annotations> & { type: \"return\" | \"returnvoid\" };\r\n    constructor(ast: Ast<Annotations> & { type: \"return\" | \"returnvoid\" }) {\r\n        this.ast = ast;\r\n    }\r\n}\r\n\r\ntype InterpreterCallbacks = {\r\n    onDisplay(x: Value): Promise<void>\r\n    onWaitForInput(): Promise<string>\r\n    onStepPause(): Promise<void>\r\n    onInfo(annotatedAst: Statement<Annotations>[], variables: VariableInfo): void\r\n}\r\n\r\nexport type VariableInfo = { globals: Map<string, Value>, locals: Map<string, Value> | null };\r\n\r\nexport class Interpreter {\r\n    globals: Map<string, Value>;\r\n    locals: Map<string, Value> | null;\r\n    callbacks: InterpreterCallbacks;\r\n    shouldCancelReal: boolean = false;\r\n    set shouldCancel(newValue: boolean) {\r\n        this.shouldCancelReal = newValue;\r\n        console.log(\"Set shouldCancel\" + newValue)\r\n    }\r\n    shouldStep: boolean = false;\r\n    annotatedAst: Statement<Annotations>[] = [];\r\n\r\n    constructor(callbacks: InterpreterCallbacks) {\r\n        this.callbacks = callbacks;\r\n        this.globals = new Map();\r\n        this.locals = null;\r\n\r\n        this.globals.set(\"DISPLAY\", {\r\n            type: \"procedure\",\r\n            builtin: true,\r\n            call: (async (ast: Ast<Annotations>, params: Value[]) => {\r\n                if (params.length !== 1) {\r\n                    this.error(ast, \"DISPLAY takes 1 argument\");\r\n                }\r\n                await this.callbacks.onDisplay(cloneDeep(params[0]));\r\n                return { type: \"void\" };\r\n            })\r\n        })\r\n\r\n        this.globals.set(\"INPUT\", {\r\n            type: \"procedure\",\r\n            builtin: true,\r\n            call: (async (ast: Ast<Annotations>, params: Value[]) => {\r\n                if (params.length !== 0) {\r\n                    this.error(ast, \"INPUT takes no arguments\");\r\n                }\r\n                const inputString = await this.callbacks.onWaitForInput();\r\n                await this.maybeCancel();\r\n                const num = Number(inputString);\r\n                if (isNaN(num)) {\r\n                    return { type: \"string\", value: inputString }\r\n                } else {\r\n                    return { type: \"number\", value: num };\r\n                }\r\n            })\r\n        })\r\n\r\n        this.globals.set(\"APPEND\", {\r\n            type: \"procedure\",\r\n            builtin: true,\r\n            call: (async (ast: Ast<Annotations> & { type: \"call\" }, params: Value[]) => {\r\n                if (params.length !== 2) {\r\n                    this.error(ast, \"APPEND takes 2 arguments\");\r\n                }\r\n                if (params[0].type !== \"list\") {\r\n                    this.error(ast.paramaters[0], \"must be a list\");\r\n                }\r\n                params[0].value.push(params[1]);\r\n\r\n                return { type: \"void\" };\r\n            })\r\n        })\r\n\r\n        this.globals.set(\"LENGTH\", {\r\n            type: \"procedure\",\r\n            builtin: true,\r\n            call: (async (ast: Ast<Annotations> & { type: \"call\" }, params: Value[]) => {\r\n                if (params.length !== 1) {\r\n                    this.error(ast, \"LENGTH takes 1 argument\");\r\n                }\r\n                if (params[0].type !== \"list\") {\r\n                    this.error(ast.paramaters[0], \"must be a list\");\r\n                }\r\n\r\n\r\n                return { type: \"number\", value: params[0].value.length };\r\n            })\r\n        })\r\n\r\n        this.globals.set(\"REMOVE\", {\r\n            type: \"procedure\",\r\n            builtin: true,\r\n            call: (async (ast: Ast<Annotations> & { type: \"call\" }, params: Value[]) => {\r\n                if (params.length !== 2) {\r\n                    this.error(ast, \"REMOVE takes 2 arguments\");\r\n                }\r\n                if (params[0].type !== \"list\") {\r\n                    this.error(ast.paramaters[0], \"must be a list\");\r\n                }\r\n                if (params[1].type !== \"number\" || !Number.isInteger(params[1].value)) {\r\n                    this.error(ast.paramaters[1], \"must be an integer\");\r\n                }\r\n                const list: Array<Value> = params[0].value;\r\n                const index: number = params[1].value;\r\n\r\n                if (index <= 0) this.error(ast.paramaters[1], \"must be >= 1\");\r\n                if (index > list.length) this.error(ast, \"index bigger than list length\");\r\n\r\n                const removed = list.splice(index - 1, 1);\r\n\r\n                return removed[0];\r\n            })\r\n        })\r\n\r\n        this.globals.set(\"INSERT\", {\r\n            type: \"procedure\",\r\n            builtin: true,\r\n            call: (async (ast: Ast<Annotations> & { type: \"call\" }, params: Value[]) => {\r\n                if (params.length !== 2) {\r\n                    this.error(ast, \"INSERT takes 3 arguments\");\r\n                }\r\n                if (params[0].type !== \"list\") {\r\n                    this.error(ast.paramaters[0], \"must be a list\");\r\n                }\r\n                if (params[1].type !== \"number\" || !Number.isInteger(params[1].value)) {\r\n                    this.error(ast.paramaters[1], \"must be an integer\");\r\n                }\r\n                const list: Array<Value> = params[0].value;\r\n                const index: number = params[1].value;\r\n\r\n                if (index <= 0) this.error(ast.paramaters[1], \"must be >= 1\");\r\n                if (index > list.length + 1) this.error(ast, \"index bigger than list length\");\r\n\r\n                list.splice(index - 1, 0, params[3]);\r\n\r\n                return { type: \"void\" };\r\n            })\r\n        })\r\n\r\n        this.globals.set(\"RANDOM\", {\r\n            type: \"procedure\",\r\n            builtin: true,\r\n            call: (async (ast: Ast<Annotations> & { type: \"call\" }, params: Value[]) => {\r\n                if (params.length !== 2) {\r\n                    this.error(ast, \"RANDOM takes 2 arguments\");\r\n                }\r\n                if (params[0].type !== \"number\" || !Number.isInteger(params[0].value)) {\r\n                    this.error(ast.paramaters[0], \"must be an integer\");\r\n                }\r\n                if (params[1].type !== \"number\" || !Number.isInteger(params[1].value)) {\r\n                    this.error(ast.paramaters[1], \"must be an integer\");\r\n                }\r\n                const a = params[0].value;\r\n                const b = params[1].value;\r\n\r\n                return { type: \"number\", value: Math.floor(Math.random() * (b - a + 1) + a) };\r\n            })\r\n        })\r\n    }\r\n\r\n\r\n    async assign(ast: AssignableExpression<Annotations>, value: Value) {\r\n        if (ast.type === \"variable\") {\r\n            if (!this.locals || this.globals.has(ast.name)) {\r\n                this.globals.set(ast.name, value);\r\n            } else {\r\n                this.locals.set(ast.name, value);\r\n            }\r\n        } else {\r\n            const index = (await this.expectType(ast.index, \"number\")).value;\r\n\r\n            const list = (await this.expectType(ast.list, \"list\")).value;\r\n\r\n            if (!Number.isInteger(index)) this.error(ast.index, \"must be an integer\");\r\n            if (index <= 0) this.error(ast.index, \"must be >= 1\");\r\n            if (index > list.length) this.error(ast, \"index bigger than list length\");\r\n\r\n            list[index - 1] = value;\r\n        }\r\n    }\r\n\r\n    interpret(asts: Statement<Annotations>[]) {\r\n        this.annotatedAst = cloneDeep(asts);\r\n        return this.runBlock(this.annotatedAst).catch(x => {\r\n            if (x instanceof ReturnException) {\r\n                this.error(x.ast, \"cannot return outside procedure\");\r\n            } else {\r\n                throw x;\r\n            }\r\n        });\r\n    }\r\n\r\n    async maybeCancel(): Promise<void> {\r\n        if (this.shouldCancelReal) {\r\n            this.shouldCancelReal = false;\r\n            throw new Cancel();\r\n        }\r\n    }\r\n\r\n    broadcastInfo() {\r\n        this.callbacks.onInfo(cloneDeep(this.annotatedAst), {\r\n            globals: cloneDeep(this.globals),\r\n            locals: cloneDeep(this.locals),\r\n        });\r\n    }\r\n\r\n    async step(ast: Ast<Annotations>): Promise<void> {\r\n        ast.isRunning = true;\r\n        this.broadcastInfo();\r\n        if (ast.type !== \"procedure\" && this.shouldStep) await this.callbacks.onStepPause();\r\n        ast.isRunning = false;\r\n    }\r\n\r\n    error(expr: Ast<Annotations>, message: string): never {\r\n        expr.error = message;\r\n        console.error(message);\r\n        this.broadcastInfo();\r\n        throw new Error(message);\r\n    }\r\n\r\n    async expectType<T extends Value[\"type\"]>(expr: Expression<Annotations>, type: T): Promise<Value & { type: T }> {\r\n        const value = await this.evaluate(expr);\r\n        if (value.type === type) {\r\n            return value as Value & { type: T };\r\n        } else {\r\n            this.error(expr, `must be a ${type}`)\r\n        }\r\n    }\r\n\r\n    async runBlock(block: Statement<Annotations>[]): Promise<void> {\r\n        for (let stat of block) {\r\n            await this.step(stat);\r\n            await this.run(stat);\r\n        }\r\n        this.broadcastInfo();\r\n    }\r\n\r\n    async run(ast: Statement<Annotations>): Promise<void> {\r\n        await this.maybeCancel();\r\n        if (ast.type === \"assign\") {\r\n            const value = await this.evaluate(ast.rhs);\r\n            await this.assign(ast.lhs, value);\r\n        } else if (ast.type === \"if\") {\r\n            const condition = (await this.expectType(ast.condition, \"boolean\")).value;\r\n            ast.condition.evaluated = { type: \"boolean\", value: condition };\r\n            if (condition) {\r\n                await this.runBlock(ast.iftrue);\r\n            }\r\n        } else if (ast.type === \"ifelse\") {\r\n            const condition = (await this.expectType(ast.condition, \"boolean\")).value;\r\n            ast.condition.evaluated = { type: \"boolean\", value: condition };\r\n            if (condition) {\r\n                await this.runBlock(ast.iftrue);\r\n            } else {\r\n                await this.runBlock(ast.iffalse);\r\n            }\r\n        } else if (ast.type === \"exprstat\") {\r\n            await this.evaluate(ast.expr);\r\n        } else if (ast.type === \"foreach\") {\r\n            const list = (await this.expectType(ast.list, \"list\")).value;\r\n            for (const x of list) {\r\n                await this.assign(ast.itemvar, x);\r\n                await this.runBlock(ast.block);\r\n            }\r\n        } else if (ast.type === \"procedure\") {\r\n            await this.assign({ type: \"variable\", name: ast.name }, {\r\n                type: \"procedure\",\r\n                builtin: false,\r\n                ast\r\n            });\r\n        } else if (ast.type === \"repeattimes\") {\r\n            const n = (await this.expectType(ast.times, \"number\")).value;\r\n            if (!Number.isInteger(n)) this.error(ast.times, \"must be an integer\");\r\n            if (n < 0) this.error(ast.times, \"must be positive\");\r\n\r\n            for (let i = 0; i < n; i++) {\r\n                await this.runBlock(ast.block);\r\n            }\r\n        } else if (ast.type === \"repeatuntil\") {\r\n            let isFirstTime = true;\r\n            while (true) {\r\n                // runBlock will step on the first time through\r\n                if (!isFirstTime) {\r\n                    await this.step(ast);\r\n                }\r\n                isFirstTime = false;\r\n                const condition = (await this.expectType(ast.condition, \"boolean\")).value;\r\n                if (condition) break;\r\n                await this.runBlock(ast.block);\r\n            }\r\n        } else if (ast.type === \"breakpoint\") {\r\n            this.shouldStep = true;\r\n            await this.step(ast);\r\n        } else if (ast.type === \"return\") {\r\n            throw new ReturnException(ast);\r\n        } else if (ast.type === \"returnvoid\") {\r\n            throw new ReturnException(ast);\r\n        }\r\n    }\r\n\r\n    async evaluate(ast: Expression<Annotations>): Promise<Value> {\r\n        await this.maybeCancel();\r\n        if (ast.type === \"operator\") {\r\n            if (ast.operator === \"!=\" || ast.operator === \"=\") {\r\n                const lhs = await this.evaluate(ast.lhs);\r\n                const rhs = await this.evaluate(ast.rhs);\r\n                const equals = isequal(lhs, rhs);\r\n\r\n                const result = ast.operator === \"!=\" ? !equals : equals;\r\n                return { type: \"boolean\", value: result };\r\n            } else if (ast.operator === \"*\" || ast.operator === \"+\" ||\r\n                ast.operator === \"-\" || ast.operator === \"/\" || ast.operator === \"MOD\") {\r\n                const a = (await this.expectType(ast.lhs, \"number\")).value;\r\n                const b = (await (this.expectType(ast.rhs, \"number\"))).value;\r\n                const value = ast.operator === \"*\" ? a * b\r\n                    : ast.operator === \"+\" ? a + b\r\n                        : ast.operator === \"-\" ? a - b\r\n                            : ast.operator === \"/\" ? a / b :\r\n                                a % b;\r\n                return { type: \"number\", value }\r\n            } else if (ast.operator === \"<\" || ast.operator === \"<=\" ||\r\n                ast.operator === \">\" || ast.operator === \">=\") {\r\n                const a = (await this.expectType(ast.lhs, \"number\")).value;\r\n                const b = (await (this.expectType(ast.rhs, \"number\"))).value;\r\n                const value = ast.operator === \">\" ? a > b\r\n                    : ast.operator === \">=\" ? a >= b\r\n                        : ast.operator === \"<\" ? a < b\r\n                            : a <= b;\r\n                return { type: \"boolean\", value };\r\n            } else if (ast.operator === \"AND\" || ast.operator === \"OR\") {\r\n                const a = (await this.expectType(ast.lhs, \"boolean\")).value;\r\n                const b = (await (this.expectType(ast.rhs, \"boolean\"))).value;\r\n                const value = ast.operator === \"AND\" ? a && b : a || b;\r\n                return { type: \"boolean\", value };\r\n            }\r\n        }\r\n        else if (ast.type === \"not\") {\r\n            const x = (await this.expectType(ast.value, \"boolean\")).value;\r\n            return { type: \"boolean\", value: !x };\r\n        } else if (ast.type === \"boolean\") {\r\n            return { type: \"boolean\", value: ast.value }\r\n        } else if (ast.type === \"number\") {\r\n            return { type: \"number\", value: ast.value }\r\n        } else if (ast.type === \"string\") {\r\n            return { type: \"string\", value: ast.value };\r\n        } else if (ast.type === \"subscript\") {\r\n            const index = (await this.expectType(ast.index, \"number\")).value;\r\n\r\n            const list = (await this.expectType(ast.list, \"list\")).value;\r\n\r\n            if (!Number.isInteger(index)) this.error(ast.index, \"must be an integer\");\r\n            if (index <= 0) this.error(ast.index, \"must be >= 1\");\r\n            if (index > list.length) this.error(ast.list, \"index bigger than list length\");\r\n\r\n            return list[index - 1];\r\n        } else if (ast.type === \"list\") {\r\n            let value: Value[] = [];\r\n            for (const item of ast.items) {\r\n                value.push(await this.evaluate(item));\r\n            }\r\n            return { type: \"list\", value }\r\n        } else if (ast.type === \"negate\") {\r\n            const num = await this.expectType(ast.value, \"number\");\r\n            return { type: \"number\", value: -num.value };\r\n        } else if (ast.type === \"variable\") {\r\n            const value = this.locals?.get(ast.name) ?? this.globals.get(ast.name);\r\n            if (value === undefined) {\r\n                this.error(ast, \"unknown name\");\r\n            }\r\n            return value;\r\n        } else if (ast.type === \"call\") {\r\n            const procedure = await this.expectType(ast.procedure, \"procedure\")\r\n            let paramaters: Value[] = [];\r\n            for (const item of ast.paramaters) {\r\n                paramaters.push(await this.evaluate(item));\r\n            }\r\n            // we need to pass the ast so it can set 'error' flag\r\n            if (procedure.builtin) {\r\n                return await procedure.call(ast, paramaters);\r\n            } else {\r\n                const nparams = procedure.ast.paramaters.length;\r\n\r\n                const oldLocals = this.locals;\r\n                this.locals = new Map();\r\n                if (paramaters.length !== nparams) {\r\n                    this.error(ast, `should have ${nparams} paramaters`);\r\n                }\r\n                for (let i = 0; i < nparams; i++) {\r\n                    this.locals.set(procedure.ast.paramaters[i], paramaters[i]);\r\n                }\r\n                try {\r\n                    await this.runBlock(procedure.ast.block);\r\n                } catch (e) {\r\n                    if (e instanceof ReturnException) {\r\n                        if (e.ast.type === \"returnvoid\") {\r\n                            return { type: \"void\" }\r\n                        } else {\r\n                            return await this.evaluate(e.ast.value);\r\n                        }\r\n                    } else {\r\n                        throw e;\r\n                    }\r\n                } finally {\r\n                    this.locals = oldLocals;\r\n                }\r\n                return { type: \"void\" }\r\n            }\r\n        }\r\n        this.error(ast, `can't handle ${ast.type}`);\r\n    }\r\n}","import React from \"react\";\r\nimport { Value } from \"./language/run\";\r\n\r\nfunction valueToString(value: Value, hideQuotes: boolean = false): string {\r\n    if (value.type === \"void\") {\r\n        return \"[void]\"\r\n    } else if (value.type === \"procedure\") {\r\n        return \"[procedure]\"\r\n    } else if (value.type === \"list\") {\r\n        let res = \"[\";\r\n        let sep = \"\";\r\n        for (const x of value.value) {\r\n            res += sep;\r\n            res += valueToString(x);\r\n            sep = \", \";\r\n        }\r\n        res += \"]\";\r\n        return res;\r\n    } else if (value.type === \"string\") {\r\n        if (hideQuotes) return value.value;\r\n        return JSON.stringify(value.value)\r\n    } else {\r\n        return value.value.toString();\r\n    }\r\n}\r\n\r\nexport default function RenderValue({ value, hideQuotes = true }: { hideQuotes?: boolean, value: Value }) {\r\n    return <span>{valueToString(value, hideQuotes)}</span>\r\n}","import { Value, VariableInfo } from \"./language/run\";\r\nimport React from \"react\";\r\nimport RenderValue from \"./RenderValue\";\r\n\r\nexport default function Variables({ variables }: { variables: VariableInfo }) {\r\n    return <div className=\"Variables\">\r\n        <h2>Variables</h2>\r\n        <h3>Globals</h3>\r\n        {Array.from(variables.globals.entries(), ([name, value]) =>\r\n            !(value.type === \"procedure\" && value.builtin) && <div className=\"variable\">\r\n                <span className=\"variableName\" key={name + \"_key\"}>{name}: </span>\r\n                <span className=\"variableValue\" key={name + \"_value\"}><RenderValue value={value} /></span>\r\n            </div>\r\n        )}\r\n        {variables.locals && <><h3>Locals</h3>\r\n            {Array.from(variables.locals.entries(), ([name, value]) =>\r\n                !(value.type === \"procedure\" && value.builtin) && <div className=\"variable\">\r\n                    <span className=\"variableName\" key={name + \"_key\"}>{name}: </span>\r\n                    <span className=\"variableValue\" key={name + \"_value\"}><RenderValue value={value} /></span>\r\n                </div>\r\n            )}</>}\r\n    </div>\r\n}","import React, { useRef, useState } from \"react\";\r\nimport { Value } from \"./language/run\";\r\nimport RenderValue from \"./RenderValue\";\r\nimport \"./Console.css\";\r\nexport type ConsoleLine = { type: \"input\", value: string } | { type: \"display\", value: Value }\r\nexport function Console({ displayed, onInput }: { displayed: ConsoleLine[], onInput: ((x: string) => void) | null }) {\r\n    const [input, setInput] = useState(\"\")\r\n    return <div className=\"Console\">\r\n        <h2>Console</h2>\r\n        <ul className=\"displayed\">\r\n            {displayed.map((x, i) => <li key={i}>\r\n                {x.type === \"display\" && <RenderValue hideQuotes value={x.value} />}\r\n                {x.type === \"input\" && <span style={{ color: \"blue\" }}>{x.value}</span>}\r\n            </li>)}\r\n        </ul>\r\n        {onInput && <form onSubmit={e => { e.preventDefault(); onInput(input); setInput(\"\") }} className=\"inputcontainer\">\r\n            <input autoFocus={true} value={input} onChange={e => setInput(e.target.value)} type=\"text\" className=\"inputbox\" /><input type=\"submit\" value=\"Submit\" />\r\n        </form>}\r\n    </div>\r\n}\r\n","import { useEffect } from \"react\";\r\nimport React from \"react\";\r\nimport { useState } from \"react\";\r\nimport { CodeBlock } from \"./CodeBlock\";\r\nimport { Statement } from \"./language/ast\";\r\nimport { Annotations, Cancel, Interpreter, RuntimeError, Value, VariableInfo } from \"./language/run\";\r\nimport RenderValue from \"./RenderValue\";\r\nimport \"./Running.css\"\r\nimport Variables from \"./Variables\";\r\nimport { Console, ConsoleLine } from \"./Console\";\r\n\r\n\r\n\r\nexport default function Running({ code, asts: unAnnotated, onClose }:\r\n    { code: string, asts: Statement[], onClose: () => void }) {\r\n\r\n\r\n    const [consoleLines, setConsoleLines] = useState<ConsoleLine[]>([]);\r\n    const [interpreter, setInterpreter] = useState<Interpreter | null>(null);\r\n    const [annotated, setAnnotated] = useState<Statement<Annotations>[]>(unAnnotated);\r\n    const [nextStep, setNextStep] = useState<(() => void) | null>(null);\r\n    const [variables, setVariables] = useState<VariableInfo>({ globals: new Map(), locals: null });\r\n    type OnInput = ((x: string) => void) | null;\r\n    const [onInput, setOnInput] = useState<OnInput>(null);\r\n\r\n    const cancel = (interpreter: Interpreter | null) => {\r\n        if (onInput) {\r\n            onInput(\"\")\r\n            setOnInput(null);\r\n        }\r\n        if (interpreter) interpreter.shouldCancel = true;\r\n        setNextStep(null);\r\n        setInterpreter(null);\r\n        setAnnotated(unAnnotated);\r\n    }\r\n\r\n    const onRun = (shouldStep: boolean) => {\r\n        setConsoleLines([]);\r\n        const newInterpreter = new Interpreter({\r\n            async onDisplay(x: Value) { setConsoleLines(old => [...old, { type: \"display\", value: x }]) },\r\n            onWaitForInput() {\r\n                return new Promise<string>(resolve => {\r\n                    setOnInput((oldOnInput: OnInput) => (x: string) => {\r\n                        setConsoleLines(old => [...old, { type: \"input\", value: x }]);\r\n                        setOnInput(null);\r\n                        resolve(x);\r\n                    })\r\n                })\r\n            },\r\n            onInfo(annotated: Statement<Annotations>[], variables: VariableInfo) {\r\n                setAnnotated(annotated);\r\n                setVariables(variables);\r\n            },\r\n            onStepPause() {\r\n                return new Promise<void>((resolve) => {\r\n                    setNextStep(nextStep => resolve);\r\n                })\r\n            }\r\n        });\r\n        setInterpreter(newInterpreter);\r\n        newInterpreter.shouldStep = shouldStep;\r\n        newInterpreter.interpret(unAnnotated)\r\n            .then(() => {\r\n                cancel(null);\r\n            })\r\n            .catch((err) => {\r\n                setNextStep(null);\r\n            })\r\n    }\r\n\r\n    return (<div className=\"Running\">\r\n        <div className=\"toolbar\">\r\n            <button onClick={e => {\r\n                cancel(interpreter);\r\n                onClose();\r\n            }}>Close</button>\r\n            {!interpreter && <button onClick={e => onRun(false)}>Run</button>}\r\n            {!interpreter && <button onClick={e => onRun(true)}>Step through</button>}\r\n            {interpreter && <button onClick={e => { cancel(interpreter) }}>Stop</button>}\r\n            {nextStep && !onInput && interpreter && <>\r\n                <button onClick={e => { interpreter.shouldStep = false; nextStep() }}>Continue</button>\r\n                <button onClick={e => nextStep()}>Step</button>\r\n            </>}\r\n        </div>\r\n        <CodeBlock asts={annotated} />\r\n        <Variables variables={variables} />\r\n        <Console displayed={consoleLines} onInput={onInput} />\r\n\r\n    </div>)\r\n}","// https://stackoverflow.com/a/64174790/13155893\r\nexport const operators = [\"+\", \"-\", \"*\", \"/\", \"MOD\"\r\n    , \"=\", \"!=\", \">\", \"<\", \">=\", \"<=\"\r\n    , \"AND\", \"OR\"] as const;\r\nexport type Operator = typeof operators[number];\r\n\r\nexport function isLiteral(x: Ast | Token): x is Literal {\r\n    return (x.type === \"string\" || x.type === \"number\" || x.type === \"boolean\");\r\n}\r\nexport type Literal =\r\n    | { type: \"string\", value: string }\r\n    | { type: \"number\", value: number }\r\n    | { type: \"boolean\", value: boolean };\r\n\r\nexport type Ast<T = {}> = Statement<T> | Expression<T>;\r\n\r\nexport type Statement<T = {}> = (\r\n    | { type: \"assign\", lhs: AssignableExpression<T>, rhs: Expression<T> }\r\n    | { type: \"if\", condition: Expression<T>, iftrue: Statement<T>[] }\r\n    | { type: \"ifelse\", condition: Expression<T>, iftrue: Statement<T>[], iffalse: Statement<T>[] }\r\n    | { type: \"repeattimes\", times: Expression<T>, block: Statement<T>[] }\r\n    | { type: \"repeatuntil\", condition: Expression<T>, block: Statement<T>[] }\r\n    | { type: \"foreach\", itemvar: AssignableExpression<T>, list: Expression<T>, block: Statement<T>[] }\r\n    | { type: \"procedure\", name: string, paramaters: string[], block: Statement<T>[] }\r\n    | { type: \"return\", value: Expression<T> }\r\n    | { type: \"returnvoid\" }\r\n    | { type: \"exprstat\", expr: Expression<T> }\r\n    | { type: \"breakpoint\" }) & T\r\n\r\n\r\nexport type Expression<T = {}> = (\r\n    | { type: \"operator\", operator: Operator, lhs: Expression<T>, rhs: Expression<T> }\r\n    | { type: \"not\", value: Expression<T> }\r\n\r\n    | { type: \"list\", items: Expression<T>[] }\r\n    | { type: \"subscript\", list: Expression<T>, index: Expression<T> }\r\n    | { type: \"call\", procedure: Expression<T>, paramaters: Expression<T>[] }\r\n    | Literal\r\n    | { type: \"variable\", name: string }\r\n    | { type: \"negate\", value: Expression<T> }) & T\r\n    ;\r\n\r\nexport type AssignableExpression<T = {}> = (\r\n    | { type: \"variable\", name: string }\r\n    | { type: \"subscript\", list: AssignableExpression<T>, index: Expression<T> }) & T\r\n\r\nexport function isAssignable(ast: Expression): ast is AssignableExpression {\r\n    return ast.type === \"variable\" || (ast.type === \"subscript\" && isAssignable(ast.list));\r\n}\r\n\r\n\r\nexport type Location = { line: number, col: number };\r\n\r\nexport const keywords = [\"AND\", \"EACH\", \"ELSE\", \"FOR\", \"IF\", \"IN\", \"MOD\", \"NOT\", \"OR\", \"PROCEDURE\", \"REPEAT\", \"RETURN\", \"TIMES\", \"UNTIL\", \"BREAKPOINT\"] as const;\r\nexport type Keyword = typeof keywords[number];\r\n\r\nexport const symbols = [\"{\", \"}\", \"[\", \"]\", \"(\", \")\", \"<-\", \",\"] as const;\r\nexport type Symbol = typeof symbols[number];\r\n\r\nexport type Token =\r\n    | { type: Operator }\r\n    | { type: Keyword }\r\n    | { type: Symbol }\r\n    | { type: \"variable\", name: string }\r\n    | Literal\r\n    ;\r\n\r\nexport type LocatedToken = Token & { location: Location }","import { Keyword, keywords, Location, operators, symbols, Token } from \"./ast\";\r\nimport { ParseError } from \"./parser\";\r\n\r\nexport function tokenize(code: string): (Token & { location: Location })[] {\r\n    let remainder = code;\r\n    let result = [];\r\n    let location = { line: 1, col: 1 };\r\n    while (!remainder.match(/^\\s*$/)) {\r\n        const { text, token, whitespace } = firstToken(remainder);\r\n        remainder = remainder.slice(text.length + whitespace.length);\r\n        for (const c of whitespace) {\r\n            if (c === \"\\n\") { location.col = 1; location.line++; } else { location.col++; }\r\n        }\r\n        for (const c of text) {\r\n            if (c === \"\\n\") { location.col = 1; location.line++; } else { location.col++; }\r\n        }\r\n        result.push({ ...token, location });\r\n    }\r\n    return result;\r\n}\r\n\r\nfunction firstToken(code: string): { whitespace: string, text: string, token: Token } {\r\n    let remainder = code;\r\n\r\n    const whitespaceMatch = /^[\\s\\n]+/.exec(code);\r\n    let whitespace = whitespaceMatch ? whitespaceMatch[0] : '';\r\n    remainder = remainder.slice(whitespace.length);\r\n\r\n    let text: string | undefined;\r\n    let token: Token | undefined;\r\n    // do numbers before symbols so negative numbers are parsed not as a negative symbol\r\n    const numberMatch = /^[0-9]*\\.?[0-9]+/.exec(remainder);\r\n    if (numberMatch) {\r\n        text = numberMatch[0];\r\n        token = { type: \"number\", value: Number.parseFloat(numberMatch[0]) };\r\n    }\r\n\r\n    if (!text) {\r\n        // sort them by length so that eg <- is found before <\r\n        const symbolsSorted = [...operators, ...symbols].sort((a, b) => b.length - a.length)\r\n        for (const sym of symbolsSorted) {\r\n            if (remainder.startsWith(sym)) {\r\n                text = sym;\r\n                token = { type: sym }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!text) {\r\n        const stringMatch = /^\"(([^\"\\\\]|(\\\\.))*)\"/.exec(remainder);\r\n        if (stringMatch) {\r\n            text = stringMatch[0];\r\n            const value = JSON.parse(stringMatch[0])\r\n            token = { type: \"string\", value };\r\n        }\r\n    }\r\n\r\n    if (!text) {\r\n        const idMatch = /^[a-zA-Z_][a-zA-Z_0-9]*/.exec(remainder);\r\n        if (idMatch) {\r\n            text = idMatch[0];\r\n            const keyword: Keyword | undefined = keywords.find((keyword) => keyword === text);\r\n            if (keyword) {\r\n                token = { type: keyword }\r\n            }\r\n            else if (text === \"true\" || text === \"false\") {\r\n                token = { type: \"boolean\", value: text === \"true\" };\r\n            } else {\r\n                token = { type: \"variable\", name: text };\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!text || !token) {\r\n        throw new ParseError({ line: 1, col: 1 }, `Unknown token starting with '${remainder.charAt(0)}'`)\r\n    }\r\n\r\n    return { text, token, whitespace };\r\n}","import { Location, Token, isLiteral, operators, isAssignable, LocatedToken, Statement, Expression } from './ast'\r\nimport { tokenize } from './tokenizer';\r\n\r\nexport class ParseError extends Error {\r\n    location: Location;\r\n    constructor(location: Location, message: string) {\r\n        super(message);\r\n        Object.setPrototypeOf(this, ParseError.prototype);\r\n\r\n        this.location = location;\r\n    }\r\n}\r\n\r\n\r\nexport function parse(code: string): Statement[] {\r\n    return new Parser(tokenize(code)).program();\r\n}\r\n\r\nexport function parseExpression(code: string): Expression {\r\n    return new Parser(tokenize(code)).expression(0);\r\n}\r\n\r\nclass Parser {\r\n    tokens: LocatedToken[];\r\n    current: number;\r\n\r\n    constructor(tokens: LocatedToken[]) {\r\n        this.tokens = tokens;\r\n        this.current = 0;\r\n    }\r\n\r\n    get next(): LocatedToken | null {\r\n        if (this.current < this.tokens.length) return this.tokens[this.current];\r\n        return null;\r\n    }\r\n\r\n    get location(): Location {\r\n        return this.next?.location ?? this.tokens[this.tokens.length - 1].location;\r\n    }\r\n\r\n    precedences: Map<Token[\"type\"], number> = new Map([\r\n        [\"+\", 60],\r\n        [\"-\", 60],\r\n        [\"*\", 70],\r\n        [\"/\", 70],\r\n        [\"MOD\", 70],\r\n        [\"=\", 40],\r\n        [\"!=\", 40],\r\n        [\">\", 50],\r\n        [\"<\", 50],\r\n        [\">=\", 50],\r\n        [\"<=\", 50],\r\n        [\"AND\", 30],\r\n        [\"OR\", 20],\r\n        [\"<-\", 10],\r\n        [\"(\", 80],\r\n        [\"[\", 80],\r\n    ])\r\n\r\n    get nextPrecedence(): number {\r\n        if (!this.next) return 0;\r\n        return this.precedences.get(this.next.type) || 0;\r\n    }\r\n\r\n    accept(type: Token[\"type\"]): Token | null {\r\n        if (this.next?.type === type) {\r\n            return this.consume();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    expect(type: Token[\"type\"], message: string): Token {\r\n        if (this.next === null || this.next.type !== type) {\r\n            throw new ParseError({ line: 1, col: 1 }, message);\r\n        } else {\r\n            return this.consume() as Token;\r\n        }\r\n    }\r\n\r\n    consume(): Token | null {\r\n        const token = this.next;\r\n        this.current++;\r\n        return token;\r\n    }\r\n\r\n    program(): Statement[] {\r\n        let result = [];\r\n        while (this.next) {\r\n            result.push(this.statement());\r\n        }\r\n        return result;\r\n    }\r\n\r\n    block(): Statement[] {\r\n        this.expect(\"{\", \"Expected a block in curly braces\");\r\n        let result = [];\r\n        while (this.next?.type !== \"}\") {\r\n            result.push(this.statement());\r\n        }\r\n        this.expect(\"}\", \"Expected a curly braces to close the block\");\r\n        return result;\r\n    }\r\n\r\n    statement(): Statement {\r\n        if (this.accept(\"IF\")) {\r\n            this.expect(\"(\", \"Expected parentheses around condition\");\r\n            const condition = this.expression(0);\r\n            this.expect(\")\", \"Expected a closing parenthesis\");\r\n            const iftrue = this.block();\r\n            if (this.accept(\"ELSE\")) {\r\n                const iffalse = this.block();\r\n                return { type: \"ifelse\", condition, iftrue, iffalse };\r\n            } else {\r\n                return { type: \"if\", condition, iftrue };\r\n            }\r\n        }\r\n        else if (this.accept(\"BREAKPOINT\")) {\r\n            return { type: \"breakpoint\" };\r\n        }\r\n        else if (this.accept(\"RETURN\")) {\r\n            if (!this.next || this.next.type === \"}\") {\r\n                return { type: \"returnvoid\" };\r\n            } else {\r\n                return { type: \"return\", value: this.expression(0) };\r\n            }\r\n        }\r\n        else if (this.accept(\"PROCEDURE\")) {\r\n            const variable = this.expect(\"variable\", \"Expected a procedure name\") as Token & { type: \"variable\" };\r\n            const name = variable.name;\r\n            this.expect(\"(\", \"Expected a '(' for the paramater list\");\r\n            const paramaters = [];\r\n            if (!this.accept(\")\")) {\r\n                do {\r\n                    const param = this.expect(\"variable\", \"Expected a paramter name\") as Token & { type: \"variable\" };\r\n                    paramaters.push(param.name);\r\n                } while (this.accept(\",\"));\r\n                this.expect(\")\", \"Expected ')' to end paramater list\");\r\n            }\r\n            return { type: \"procedure\", name, paramaters, block: this.block() };\r\n\r\n        } else if (this.accept(\"REPEAT\")) {\r\n            if (this.accept(\"UNTIL\")) {\r\n                this.expect(\"(\", \"Expected parentheses around condition\");\r\n                const condition = this.expression(0);\r\n                this.expect(\")\", \"Expected a closing parenthesis\");\r\n                return { type: \"repeatuntil\", condition, block: this.block() };\r\n            } else {\r\n                const times = this.expression(0);\r\n                this.expect(\"TIMES\", \"Repeat must be REPEAT n TIMES or REPEAT UNTIL(condition)\");\r\n                return { type: \"repeattimes\", times, block: this.block() };\r\n            }\r\n        } else if (this.accept(\"FOR\")) {\r\n            this.expect(\"EACH\", \"FOR needs to have FOR EACH\");\r\n            const itemvar = this.expect(\"variable\", \"FOR EACH needs a variable\") as Expression;\r\n            this.expect(\"IN\", \"FOR EACH needs an IN\");\r\n            const list = this.expression(0);\r\n            const block = this.block();\r\n            if (!isAssignable(itemvar)) {\r\n                throw new ParseError(this.location, \"must be a variable name\");\r\n            }\r\n            return { type: \"foreach\", itemvar, list, block };\r\n        } else {\r\n            // assignment is parsed with expressions since it is impossible to know\r\n            // if it is an assignment or something else when you look at it.\r\n\r\n            const expr = this.expression(0, true);\r\n\r\n            if (expr.type === \"assign\") {\r\n                return expr;\r\n            }\r\n            else {\r\n                return { type: \"exprstat\", expr }\r\n            };\r\n        }\r\n    }\r\n\r\n    primary(isStatement: boolean = false): Expression {\r\n        if (this.accept(\"NOT\")) {\r\n            return { type: \"not\", value: this.expression(0) }\r\n        }\r\n        else if (this.accept(\"-\")) {\r\n            return { type: \"negate\", value: this.expression(0) }\r\n        } else if (this.next && isLiteral(this.next)) {\r\n            const literal = this.next;\r\n            this.consume();\r\n            return literal;\r\n        } else if (this.accept(\"(\")) {\r\n            const expr = this.expression(0);\r\n            this.expect(\")\", \"Closing paren\");\r\n            return expr;\r\n        } else if (this.accept(\"[\")) {\r\n            let items = [];\r\n            if (!this.accept(\"]\")) {\r\n                do {\r\n                    items.push(this.expression(0));\r\n                } while (this.accept(\",\"));\r\n                this.expect(\"]\", \"Expected close bracket to end list\");\r\n            }\r\n            return { type: \"list\", items };\r\n        } else if (this.next?.type === 'variable') {\r\n            const expr: Expression = { type: 'variable', name: this.next.name };\r\n            this.consume();\r\n            return expr;\r\n        } else if (this.accept(\")\")) {\r\n            throw new ParseError(this.location, `This ')' has no matching '(' to close`);\r\n        } else if (this.accept(\"]\")) {\r\n            throw new ParseError(this.location, `This ']' has no matching '[' to close`);\r\n        } else {\r\n            throw new ParseError(this.location, `Expected an expression${isStatement ? \" or statement\" : \"\"}`);\r\n        }\r\n    }\r\n\r\n    expression(minPrecToStop: number): Expression;\r\n    expression(minPrecToStop: number, isStatement: false): Expression;\r\n    expression(minPrecToStop: number, isStatement: true): Expression | (Statement & { type: \"assign\" });\r\n\r\n    expression(minPrecToStop: number, isStatement: boolean = false): Expression | (Statement & { type: \"assign\" }) {\r\n        let result = this.primary(isStatement);\r\n\r\n        while (minPrecToStop < this.nextPrecedence) {\r\n            const token = this.consume();\r\n            if (!token) break;\r\n\r\n            const op = operators.find((x) => x === token.type);\r\n            if (op) {\r\n                // a regular operator\r\n                const rhs = this.expression(this.precedences.get(op) || 0, false);\r\n                result = { type: \"operator\", operator: op, lhs: result, rhs }\r\n            } else if (token.type === \"(\") {\r\n                let paramaters = [];\r\n                if (!this.accept(\")\")) {\r\n                    do {\r\n                        paramaters.push(this.expression(0));\r\n                    } while (this.accept(\",\"));\r\n                    this.expect(\")\", \"Expected ')' to end paramater list\");\r\n                }\r\n                result = { type: \"call\", procedure: result, paramaters };\r\n            } else if (token.type === \"[\") {\r\n                const index = this.expression(0);\r\n                this.expect(\"]\", \"Expected a ']' to close the list\");\r\n                result = { type: \"subscript\", list: result, index };\r\n            } else if (token.type === \"<-\") {\r\n                if (isStatement) {\r\n                    if (!isAssignable(result)) throw new ParseError(this.location, \"Can only assign to a variable or list item\");\r\n                    return { type: \"assign\", lhs: result, rhs: this.expression(0) };\r\n                } else {\r\n                    throw new ParseError(this.location, \"Assignment must be a statement\");\r\n                }\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}","import React, { useState } from 'react';\nimport Editor from './Editor';\nimport Running from './Running';\nimport { parse, ParseError } from './language/parser'\nimport './App.css';\nimport { Statement } from './language/ast';\n\nfunction App() {\n  type Data =\n    | { mode: \"editing\", code: string }\n    | { mode: \"running\", code: string, asts: Statement[] };\n  const [data, setData] = useState<Data>({ mode: \"editing\", code: \"\" });\n  const [error, setError] = useState<ParseError | null>(null);\n\n  function onRun() {\n    try {\n      setData({\n        mode: \"running\",\n        code: data.code,\n        asts: parse(data.code)\n      });\n      setError(null);\n    } catch (e) {\n      if (e instanceof ParseError) {\n        setError(e);\n      } else {\n        throw e;\n      }\n    }\n  }\n  let content;\n  if (data.mode === \"editing\") {\n    content = <Editor code={data.code} setCode={(code) => setData({ ...data, code })} onRun={onRun} error={error} />\n  } else if (data.mode === \"running\") {\n    content = <Running code={data.code} asts={data.asts} onClose={() => setData({ mode: \"editing\", code: data.code })} />\n  }\n\n  return (\n    <div className=\"App\">\n      {content}\n      <footer><div>Based on the AP® Computer Science Principles exam&apos;s <a href=\"https://apcentral.collegeboard.org/pdf/ap-computer-science-principles-exam-reference-sheet.pdf\">reference sheet.</a></div><div>AP® is a trademark registered by the College Board, which is not affiliated with, and does not endorse, this site.</div></footer>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    }, () => { });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}