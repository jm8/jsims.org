<!DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link href="https://fonts.googleapis.com/css?family=Nunito+Sans:400,400i,700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="/darby-capstone-blog/assets/css/style.css">
<title>Parsing Expressions</title>
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Parsing Expressions</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Parsing Expressions" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="As I said last time, parsing expressions is a lot harder than statements. For statements, if you see an IF, you know exactly what to do: expect a (, an expression, a ), and then a curly-braced block with more statements. If the next token is an ELSE, than you’ll take another block. However, with expressions it’s not so easy. Let’s use the example of x[3] &lt;- 3*y+f(a, b) Sidenote: I made the expression function parse assignment, since it looks like an expression if you just see the x. So I made two overloads: expression(minPrecToStop: number, isStatement: false): Expression; expression(minPrecToStop: number, isStatement: true): Expression | (Statement &amp; { type: &quot;assign&quot; }); And made it so if it is not expecting an assignment, it throws an error. expression(minPrecToStop: number, isStatement: boolean = false): Expression | (Statement &amp; { type: &quot;assign&quot; }) { else if (token.type === &quot;&lt;-&quot;) { if (isStatement) { if (!isAssignable(result)) throw new ParseError(this.location, &quot;Can only assign to a variable or list item&quot;); return { type: &quot;assign&quot;, lhs: result, rhs: this.expression(0) }; } else { throw new ParseError(this.location, &quot;Assignment must be a statement&quot;); } } /* ... */ } When we parse a statement, if it’s not one of the IFs or REPEATs etc. we have to call expression, then it might be an assign, or a function call or something. statement(): Statement { /* ... */ } else { // assignment is parsed with expressions since it is impossible to know // if it is an assignment or something else when you look at it. const expr = this.expression(0, true); if (expr.type === &quot;assign&quot;) { return expr; } else { return { type: &quot;exprstat&quot;, expr } }; } } Anyway, we are looking at our example, which gets tokenized like this: [ { &quot;type&quot;:&quot;variable&quot;, &quot;name&quot;:&quot;x&quot; }, { &quot;type&quot;:&quot;[&quot; }, { &quot;type&quot;:&quot;number&quot;, &quot;value&quot;:3 }, { &quot;type&quot;:&quot;]&quot; }, { &quot;type&quot;:&quot;&lt;-&quot; }, { &quot;type&quot;:&quot;number&quot;, &quot;value&quot;:3 }, { &quot;type&quot;:&quot;*&quot; }, { &quot;type&quot;:&quot;variable&quot;, &quot;name&quot;:&quot;y&quot; }, { &quot;type&quot;:&quot;*&quot; }, { &quot;type&quot;:&quot;variable&quot;, &quot;name&quot;:&quot;f&quot; }, { &quot;type&quot;:&quot;(&quot; }, { &quot;type&quot;:&quot;variable&quot;, &quot;name&quot;:&quot;a&quot; }, { &quot;type&quot;:&quot;,&quot; }, { &quot;type&quot;:&quot;variable&quot;, &quot;name&quot;:&quot;b&quot; }, { &quot;type&quot;:&quot;)&quot; } ] For parsing I have mostly been using “recursive decent”, which basically means calling functions that parse different parse of your code recursively. But for parsing expressions with operator precedence, it means I will have to use a more complicated technique, which I am using called “Pratt Parsing”. I used this blog post which explains it. We have to assign a precedence or “binding power” to each operator or symbol. Anything not in this Map will have a binding power of 0, meaning it won’t be added to any expression. precedences: Map&lt;Token[&quot;type&quot;], number&gt; = new Map([ [&quot;+&quot;, 60], [&quot;-&quot;, 60], [&quot;*&quot;, 70], [&quot;/&quot;, 70], [&quot;MOD&quot;, 70], [&quot;=&quot;, 40], [&quot;!=&quot;, 40], [&quot;&gt;&quot;, 50], [&quot;&lt;&quot;, 50], [&quot;&gt;=&quot;, 50], [&quot;&lt;=&quot;, 50], [&quot;AND&quot;, 30], [&quot;OR&quot;, 20], [&quot;&lt;-&quot;, 10], [&quot;(&quot;, 80], [&quot;[&quot;, 80], ]) get nextPrecedence(): number { if (!this.next) return 0; return this.precedences.get(this.next.type) || 0; } So now we are ready to parse our example. We are on the first token, x. This is the full code of expression if it helps to follow along: expression(minPrecToStop: number, isStatement: boolean = false): Expression | (Statement &amp; { type: &quot;assign&quot; }) { let result = this.primary(isStatement); while (minPrecToStop &lt; this.nextPrecedence) { const token = this.consume(); if (!token) break; const op = operators.find((x) =&gt; x === token.type); if (op) { // a regular operator const rhs = this.expression(this.precedences.get(op) || 0, false); result = { type: &quot;operator&quot;, operator: op, lhs: result, rhs } } else if (token.type === &quot;(&quot;) { let paramaters = []; if (!this.accept(&quot;)&quot;)) { do { paramaters.push(this.expression(0)); } while (this.accept(&quot;,&quot;)); this.expect(&quot;)&quot;, &quot;Expected &#39;)&#39; to end paramater list&quot;); } result = { type: &quot;call&quot;, procedure: result, paramaters }; } else if (token.type === &quot;[&quot;) { const index = this.expression(0); this.expect(&quot;]&quot;, &quot;Expected a &#39;]&#39; to close the list&quot;); result = { type: &quot;subscript&quot;, list: result, index }; } else if (token.type === &quot;&lt;-&quot;) { if (isStatement) { if (!isAssignable(result)) throw new ParseError(this.location, &quot;Can only assign to a variable or list item&quot;); return { type: &quot;assign&quot;, lhs: result, rhs: this.expression(0) }; } else { throw new ParseError(this.location, &quot;Assignment must be a statement&quot;); } } } return result; } Whenever we start parsing an expression, we call this.primary(), which handles variables, literals, lists, and expressions in parentheses. In this case, it gives us just the variable x. Next we see the [. This has a binding power of 80 (the highest it goes), but we wouldn’t stop anyway, since we will only if we find something with 0 binding power (the start of the next statement, which would probably be a keyword or variable). When we see the [, it means it’s a subscript and we need the index. So we recurseivly call this.expression(0) to get the inside expression. Now back at the start, we get a this.primary(). This is just the number 3. The next token is ], which has 0 binding power since it’s not in the map. So we just return the number 3. Back outside, we remember we are parsing a list subscript, so we eat the ]. Our result is now the subscript expression, with list: the variable x (remember this was our result from earlier), and with index: the number 3. The next token is &lt;-, which has 10 binding power, so we are going to add it on to our current expression. We are going back through the while loop. We are going to recurse this.expression(0) to get the right side of the assignment. We also check that our expression on the left is assignable, which it is. Now back at the top of expression, we get a primary (the other number 3). Our next token is a *, so go into the if (op). The rhs is yet another call to expression, but this time we give it a minPrecToStop. We don’t want it to eat the rest of the expression, which would give us 3*(y+f(a,b)). We want it to stop if it gets to anything with less binding power than *. Therefore, we look up the precedence for *, which is 70. We will stop if we get to anything with less precedence than 70. So we get a this.primary(), which is the variable y. But now the next precedence is for +, which is only 60. So we stop and return. The rhs of the multiplication is only y, not y+f(a,b), because we stop at the +. Now we are back out into parsing the right side of the assignment. We are going to keep parsing the rest of the expression (minPrecToStop = 0), so we take the plus. We call this.expression with minPrecToStop of 60, although that won’t matter in this case. We get a primary (f). Then it’s a (. Binding power let’s us handle function calls as well as operators. So we get the arguments until we run out of commas. All of the calls to this.expression(0) will stop at the comma, since comma has 0 binding power. Then we take the ), create the function call ast, and it onto our 3*y Now there’s no way anything could eat anymore, so we’re done." />
<meta property="og:description" content="As I said last time, parsing expressions is a lot harder than statements. For statements, if you see an IF, you know exactly what to do: expect a (, an expression, a ), and then a curly-braced block with more statements. If the next token is an ELSE, than you’ll take another block. However, with expressions it’s not so easy. Let’s use the example of x[3] &lt;- 3*y+f(a, b) Sidenote: I made the expression function parse assignment, since it looks like an expression if you just see the x. So I made two overloads: expression(minPrecToStop: number, isStatement: false): Expression; expression(minPrecToStop: number, isStatement: true): Expression | (Statement &amp; { type: &quot;assign&quot; }); And made it so if it is not expecting an assignment, it throws an error. expression(minPrecToStop: number, isStatement: boolean = false): Expression | (Statement &amp; { type: &quot;assign&quot; }) { else if (token.type === &quot;&lt;-&quot;) { if (isStatement) { if (!isAssignable(result)) throw new ParseError(this.location, &quot;Can only assign to a variable or list item&quot;); return { type: &quot;assign&quot;, lhs: result, rhs: this.expression(0) }; } else { throw new ParseError(this.location, &quot;Assignment must be a statement&quot;); } } /* ... */ } When we parse a statement, if it’s not one of the IFs or REPEATs etc. we have to call expression, then it might be an assign, or a function call or something. statement(): Statement { /* ... */ } else { // assignment is parsed with expressions since it is impossible to know // if it is an assignment or something else when you look at it. const expr = this.expression(0, true); if (expr.type === &quot;assign&quot;) { return expr; } else { return { type: &quot;exprstat&quot;, expr } }; } } Anyway, we are looking at our example, which gets tokenized like this: [ { &quot;type&quot;:&quot;variable&quot;, &quot;name&quot;:&quot;x&quot; }, { &quot;type&quot;:&quot;[&quot; }, { &quot;type&quot;:&quot;number&quot;, &quot;value&quot;:3 }, { &quot;type&quot;:&quot;]&quot; }, { &quot;type&quot;:&quot;&lt;-&quot; }, { &quot;type&quot;:&quot;number&quot;, &quot;value&quot;:3 }, { &quot;type&quot;:&quot;*&quot; }, { &quot;type&quot;:&quot;variable&quot;, &quot;name&quot;:&quot;y&quot; }, { &quot;type&quot;:&quot;*&quot; }, { &quot;type&quot;:&quot;variable&quot;, &quot;name&quot;:&quot;f&quot; }, { &quot;type&quot;:&quot;(&quot; }, { &quot;type&quot;:&quot;variable&quot;, &quot;name&quot;:&quot;a&quot; }, { &quot;type&quot;:&quot;,&quot; }, { &quot;type&quot;:&quot;variable&quot;, &quot;name&quot;:&quot;b&quot; }, { &quot;type&quot;:&quot;)&quot; } ] For parsing I have mostly been using “recursive decent”, which basically means calling functions that parse different parse of your code recursively. But for parsing expressions with operator precedence, it means I will have to use a more complicated technique, which I am using called “Pratt Parsing”. I used this blog post which explains it. We have to assign a precedence or “binding power” to each operator or symbol. Anything not in this Map will have a binding power of 0, meaning it won’t be added to any expression. precedences: Map&lt;Token[&quot;type&quot;], number&gt; = new Map([ [&quot;+&quot;, 60], [&quot;-&quot;, 60], [&quot;*&quot;, 70], [&quot;/&quot;, 70], [&quot;MOD&quot;, 70], [&quot;=&quot;, 40], [&quot;!=&quot;, 40], [&quot;&gt;&quot;, 50], [&quot;&lt;&quot;, 50], [&quot;&gt;=&quot;, 50], [&quot;&lt;=&quot;, 50], [&quot;AND&quot;, 30], [&quot;OR&quot;, 20], [&quot;&lt;-&quot;, 10], [&quot;(&quot;, 80], [&quot;[&quot;, 80], ]) get nextPrecedence(): number { if (!this.next) return 0; return this.precedences.get(this.next.type) || 0; } So now we are ready to parse our example. We are on the first token, x. This is the full code of expression if it helps to follow along: expression(minPrecToStop: number, isStatement: boolean = false): Expression | (Statement &amp; { type: &quot;assign&quot; }) { let result = this.primary(isStatement); while (minPrecToStop &lt; this.nextPrecedence) { const token = this.consume(); if (!token) break; const op = operators.find((x) =&gt; x === token.type); if (op) { // a regular operator const rhs = this.expression(this.precedences.get(op) || 0, false); result = { type: &quot;operator&quot;, operator: op, lhs: result, rhs } } else if (token.type === &quot;(&quot;) { let paramaters = []; if (!this.accept(&quot;)&quot;)) { do { paramaters.push(this.expression(0)); } while (this.accept(&quot;,&quot;)); this.expect(&quot;)&quot;, &quot;Expected &#39;)&#39; to end paramater list&quot;); } result = { type: &quot;call&quot;, procedure: result, paramaters }; } else if (token.type === &quot;[&quot;) { const index = this.expression(0); this.expect(&quot;]&quot;, &quot;Expected a &#39;]&#39; to close the list&quot;); result = { type: &quot;subscript&quot;, list: result, index }; } else if (token.type === &quot;&lt;-&quot;) { if (isStatement) { if (!isAssignable(result)) throw new ParseError(this.location, &quot;Can only assign to a variable or list item&quot;); return { type: &quot;assign&quot;, lhs: result, rhs: this.expression(0) }; } else { throw new ParseError(this.location, &quot;Assignment must be a statement&quot;); } } } return result; } Whenever we start parsing an expression, we call this.primary(), which handles variables, literals, lists, and expressions in parentheses. In this case, it gives us just the variable x. Next we see the [. This has a binding power of 80 (the highest it goes), but we wouldn’t stop anyway, since we will only if we find something with 0 binding power (the start of the next statement, which would probably be a keyword or variable). When we see the [, it means it’s a subscript and we need the index. So we recurseivly call this.expression(0) to get the inside expression. Now back at the start, we get a this.primary(). This is just the number 3. The next token is ], which has 0 binding power since it’s not in the map. So we just return the number 3. Back outside, we remember we are parsing a list subscript, so we eat the ]. Our result is now the subscript expression, with list: the variable x (remember this was our result from earlier), and with index: the number 3. The next token is &lt;-, which has 10 binding power, so we are going to add it on to our current expression. We are going back through the while loop. We are going to recurse this.expression(0) to get the right side of the assignment. We also check that our expression on the left is assignable, which it is. Now back at the top of expression, we get a primary (the other number 3). Our next token is a *, so go into the if (op). The rhs is yet another call to expression, but this time we give it a minPrecToStop. We don’t want it to eat the rest of the expression, which would give us 3*(y+f(a,b)). We want it to stop if it gets to anything with less binding power than *. Therefore, we look up the precedence for *, which is 70. We will stop if we get to anything with less precedence than 70. So we get a this.primary(), which is the variable y. But now the next precedence is for +, which is only 60. So we stop and return. The rhs of the multiplication is only y, not y+f(a,b), because we stop at the +. Now we are back out into parsing the right side of the assignment. We are going to keep parsing the rest of the expression (minPrecToStop = 0), so we take the plus. We call this.expression with minPrecToStop of 60, although that won’t matter in this case. We get a primary (f). Then it’s a (. Binding power let’s us handle function calls as well as operators. So we get the arguments until we run out of commas. All of the calls to this.expression(0) will stop at the comma, since comma has 0 binding power. Then we take the ), create the function call ast, and it onto our 3*y Now there’s no way anything could eat anymore, so we’re done." />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-08-12T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Parsing Expressions" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"/darby-capstone-blog/2021/08/12/parsing-expressions.html"},"@type":"BlogPosting","description":"As I said last time, parsing expressions is a lot harder than statements. For statements, if you see an IF, you know exactly what to do: expect a (, an expression, a ), and then a curly-braced block with more statements. If the next token is an ELSE, than you’ll take another block. However, with expressions it’s not so easy. Let’s use the example of x[3] &lt;- 3*y+f(a, b) Sidenote: I made the expression function parse assignment, since it looks like an expression if you just see the x. So I made two overloads: expression(minPrecToStop: number, isStatement: false): Expression; expression(minPrecToStop: number, isStatement: true): Expression | (Statement &amp; { type: &quot;assign&quot; }); And made it so if it is not expecting an assignment, it throws an error. expression(minPrecToStop: number, isStatement: boolean = false): Expression | (Statement &amp; { type: &quot;assign&quot; }) { else if (token.type === &quot;&lt;-&quot;) { if (isStatement) { if (!isAssignable(result)) throw new ParseError(this.location, &quot;Can only assign to a variable or list item&quot;); return { type: &quot;assign&quot;, lhs: result, rhs: this.expression(0) }; } else { throw new ParseError(this.location, &quot;Assignment must be a statement&quot;); } } /* ... */ } When we parse a statement, if it’s not one of the IFs or REPEATs etc. we have to call expression, then it might be an assign, or a function call or something. statement(): Statement { /* ... */ } else { // assignment is parsed with expressions since it is impossible to know // if it is an assignment or something else when you look at it. const expr = this.expression(0, true); if (expr.type === &quot;assign&quot;) { return expr; } else { return { type: &quot;exprstat&quot;, expr } }; } } Anyway, we are looking at our example, which gets tokenized like this: [ { &quot;type&quot;:&quot;variable&quot;, &quot;name&quot;:&quot;x&quot; }, { &quot;type&quot;:&quot;[&quot; }, { &quot;type&quot;:&quot;number&quot;, &quot;value&quot;:3 }, { &quot;type&quot;:&quot;]&quot; }, { &quot;type&quot;:&quot;&lt;-&quot; }, { &quot;type&quot;:&quot;number&quot;, &quot;value&quot;:3 }, { &quot;type&quot;:&quot;*&quot; }, { &quot;type&quot;:&quot;variable&quot;, &quot;name&quot;:&quot;y&quot; }, { &quot;type&quot;:&quot;*&quot; }, { &quot;type&quot;:&quot;variable&quot;, &quot;name&quot;:&quot;f&quot; }, { &quot;type&quot;:&quot;(&quot; }, { &quot;type&quot;:&quot;variable&quot;, &quot;name&quot;:&quot;a&quot; }, { &quot;type&quot;:&quot;,&quot; }, { &quot;type&quot;:&quot;variable&quot;, &quot;name&quot;:&quot;b&quot; }, { &quot;type&quot;:&quot;)&quot; } ] For parsing I have mostly been using “recursive decent”, which basically means calling functions that parse different parse of your code recursively. But for parsing expressions with operator precedence, it means I will have to use a more complicated technique, which I am using called “Pratt Parsing”. I used this blog post which explains it. We have to assign a precedence or “binding power” to each operator or symbol. Anything not in this Map will have a binding power of 0, meaning it won’t be added to any expression. precedences: Map&lt;Token[&quot;type&quot;], number&gt; = new Map([ [&quot;+&quot;, 60], [&quot;-&quot;, 60], [&quot;*&quot;, 70], [&quot;/&quot;, 70], [&quot;MOD&quot;, 70], [&quot;=&quot;, 40], [&quot;!=&quot;, 40], [&quot;&gt;&quot;, 50], [&quot;&lt;&quot;, 50], [&quot;&gt;=&quot;, 50], [&quot;&lt;=&quot;, 50], [&quot;AND&quot;, 30], [&quot;OR&quot;, 20], [&quot;&lt;-&quot;, 10], [&quot;(&quot;, 80], [&quot;[&quot;, 80], ]) get nextPrecedence(): number { if (!this.next) return 0; return this.precedences.get(this.next.type) || 0; } So now we are ready to parse our example. We are on the first token, x. This is the full code of expression if it helps to follow along: expression(minPrecToStop: number, isStatement: boolean = false): Expression | (Statement &amp; { type: &quot;assign&quot; }) { let result = this.primary(isStatement); while (minPrecToStop &lt; this.nextPrecedence) { const token = this.consume(); if (!token) break; const op = operators.find((x) =&gt; x === token.type); if (op) { // a regular operator const rhs = this.expression(this.precedences.get(op) || 0, false); result = { type: &quot;operator&quot;, operator: op, lhs: result, rhs } } else if (token.type === &quot;(&quot;) { let paramaters = []; if (!this.accept(&quot;)&quot;)) { do { paramaters.push(this.expression(0)); } while (this.accept(&quot;,&quot;)); this.expect(&quot;)&quot;, &quot;Expected &#39;)&#39; to end paramater list&quot;); } result = { type: &quot;call&quot;, procedure: result, paramaters }; } else if (token.type === &quot;[&quot;) { const index = this.expression(0); this.expect(&quot;]&quot;, &quot;Expected a &#39;]&#39; to close the list&quot;); result = { type: &quot;subscript&quot;, list: result, index }; } else if (token.type === &quot;&lt;-&quot;) { if (isStatement) { if (!isAssignable(result)) throw new ParseError(this.location, &quot;Can only assign to a variable or list item&quot;); return { type: &quot;assign&quot;, lhs: result, rhs: this.expression(0) }; } else { throw new ParseError(this.location, &quot;Assignment must be a statement&quot;); } } } return result; } Whenever we start parsing an expression, we call this.primary(), which handles variables, literals, lists, and expressions in parentheses. In this case, it gives us just the variable x. Next we see the [. This has a binding power of 80 (the highest it goes), but we wouldn’t stop anyway, since we will only if we find something with 0 binding power (the start of the next statement, which would probably be a keyword or variable). When we see the [, it means it’s a subscript and we need the index. So we recurseivly call this.expression(0) to get the inside expression. Now back at the start, we get a this.primary(). This is just the number 3. The next token is ], which has 0 binding power since it’s not in the map. So we just return the number 3. Back outside, we remember we are parsing a list subscript, so we eat the ]. Our result is now the subscript expression, with list: the variable x (remember this was our result from earlier), and with index: the number 3. The next token is &lt;-, which has 10 binding power, so we are going to add it on to our current expression. We are going back through the while loop. We are going to recurse this.expression(0) to get the right side of the assignment. We also check that our expression on the left is assignable, which it is. Now back at the top of expression, we get a primary (the other number 3). Our next token is a *, so go into the if (op). The rhs is yet another call to expression, but this time we give it a minPrecToStop. We don’t want it to eat the rest of the expression, which would give us 3*(y+f(a,b)). We want it to stop if it gets to anything with less binding power than *. Therefore, we look up the precedence for *, which is 70. We will stop if we get to anything with less precedence than 70. So we get a this.primary(), which is the variable y. But now the next precedence is for +, which is only 60. So we stop and return. The rhs of the multiplication is only y, not y+f(a,b), because we stop at the +. Now we are back out into parsing the right side of the assignment. We are going to keep parsing the rest of the expression (minPrecToStop = 0), so we take the plus. We call this.expression with minPrecToStop of 60, although that won’t matter in this case. We get a primary (f). Then it’s a (. Binding power let’s us handle function calls as well as operators. So we get the arguments until we run out of commas. All of the calls to this.expression(0) will stop at the comma, since comma has 0 binding power. Then we take the ), create the function call ast, and it onto our 3*y Now there’s no way anything could eat anymore, so we’re done.","headline":"Parsing Expressions","dateModified":"2021-08-12T00:00:00-04:00","datePublished":"2021-08-12T00:00:00-04:00","url":"/darby-capstone-blog/2021/08/12/parsing-expressions.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
</head>
<body>
  <header class="texture-red">
    <div class="container"><div class="navbar">
	<ul>
		
		<a href="/"><li  >About</li></a>
		
		<a href="/expectations"><li  >Expectations</li></a>
		
		<a href="/experience"><li  >Experience</li></a>
		
		<a href="/mentor"><li  >Mentor</li></a>
		
		<a href="/interview"><li  >Interview</li></a>
		
		<a href="/reflection"><li  >Reflection</li></a>
		
		<a href="https://jsims.org/apcsp"><li  >Run my Project</li></a>
		
	</ul>
</div></div><div class="container">
	<h1>Parsing Expressions</h1>
	<h4 class="post-description"></h4>
	<div class="post-date" style="margin-top:20px">
		Published on Aug 12, 2021
	</div>
	<ul class="post-tags"></ul>
</div>
</header>
  <main>
    <div class="container">
      <div class="post-container">
          <p>As I said last time, parsing expressions is a lot harder than statements. For statements, if you see an <code class="language-plaintext highlighter-rouge">IF</code>, you know exactly what to do: expect a <code class="language-plaintext highlighter-rouge">(</code>, an expression, a <code class="language-plaintext highlighter-rouge">)</code>, and then a curly-braced block with more statements. If the next token is an <code class="language-plaintext highlighter-rouge">ELSE</code>, than you’ll take another block.</p>

<p>However, with expressions it’s not so easy. Let’s use the example of</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>x[3] &lt;- 3*y+f(a, b)
</code></pre></div></div>

<p>Sidenote: I made the <code class="language-plaintext highlighter-rouge">expression</code> function parse assignment, since it looks like an expression if you just see the <code class="language-plaintext highlighter-rouge">x</code>. So I made two overloads:</p>
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">expression</span><span class="p">(</span><span class="nx">minPrecToStop</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">isStatement</span><span class="p">:</span> <span class="kc">false</span><span class="p">):</span> <span class="nx">Expression</span><span class="p">;</span>
<span class="nx">expression</span><span class="p">(</span><span class="nx">minPrecToStop</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">isStatement</span><span class="p">:</span> <span class="kc">true</span><span class="p">):</span> <span class="nx">Expression</span> <span class="o">|</span> <span class="p">(</span><span class="nx">Statement</span> <span class="o">&amp;</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">assign</span><span class="dl">"</span> <span class="p">});</span>
</code></pre></div></div>

<p>And made it so if it is not expecting an assignment, it throws an error.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">expression</span><span class="p">(</span><span class="nx">minPrecToStop</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">isStatement</span><span class="p">:</span> <span class="nx">boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="p">):</span> <span class="nx">Expression</span> <span class="o">|</span> <span class="p">(</span><span class="nx">Statement</span> <span class="o">&amp;</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">assign</span><span class="dl">"</span> <span class="p">})</span> <span class="p">{</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">&lt;-</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">isStatement</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isAssignable</span><span class="p">(</span><span class="nx">result</span><span class="p">))</span> <span class="k">throw</span> <span class="k">new</span> <span class="nx">ParseError</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">location</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Can only assign to a variable or list item</span><span class="dl">"</span><span class="p">);</span>
            <span class="k">return</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">assign</span><span class="dl">"</span><span class="p">,</span> <span class="na">lhs</span><span class="p">:</span> <span class="nx">result</span><span class="p">,</span> <span class="na">rhs</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">expression</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">};</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nx">ParseError</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">location</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Assignment must be a statement</span><span class="dl">"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>When we parse a statement, if it’s not one of the <code class="language-plaintext highlighter-rouge">IF</code>s or <code class="language-plaintext highlighter-rouge">REPEAT</code>s etc. we have to call <code class="language-plaintext highlighter-rouge">expression</code>, then it might be an assign, or a function call or something.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">statement</span><span class="p">():</span> <span class="nx">Statement</span> <span class="p">{</span>
    <span class="cm">/* ... */</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// assignment is parsed with expressions since it is impossible to know</span>
        <span class="c1">// if it is an assignment or something else when you look at it.</span>

        <span class="kd">const</span> <span class="nx">expr</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">expression</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">expr</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">assign</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nx">expr</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">exprstat</span><span class="dl">"</span><span class="p">,</span> <span class="nx">expr</span> <span class="p">}</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Anyway, we are looking at our example, which gets tokenized like this:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="s2">"variable"</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="s2">"x"</span><span class="w"> </span><span class="p">},</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="s2">"["</span><span class="w"> </span><span class="p">},</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="s2">"number"</span><span class="p">,</span><span class="w"> </span><span class="nl">"value"</span><span class="p">:</span><span class="mi">3</span><span class="w"> </span><span class="p">},</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="s2">"]"</span><span class="w"> </span><span class="p">},</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="s2">"&lt;-"</span><span class="w"> </span><span class="p">},</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="s2">"number"</span><span class="p">,</span><span class="w"> </span><span class="nl">"value"</span><span class="p">:</span><span class="mi">3</span><span class="w"> </span><span class="p">},</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="s2">"*"</span><span class="w"> </span><span class="p">},</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="s2">"variable"</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="s2">"y"</span><span class="w"> </span><span class="p">},</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="s2">"*"</span><span class="w"> </span><span class="p">},</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="s2">"variable"</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="s2">"f"</span><span class="w"> </span><span class="p">},</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="s2">"("</span><span class="w"> </span><span class="p">},</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="s2">"variable"</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="s2">"a"</span><span class="w"> </span><span class="p">},</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="s2">","</span><span class="w"> </span><span class="p">},</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="s2">"variable"</span><span class="p">,</span><span class="w"> </span><span class="nl">"name"</span><span class="p">:</span><span class="s2">"b"</span><span class="w"> </span><span class="p">},</span><span class="w">
   </span><span class="p">{</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="s2">")"</span><span class="w"> </span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre></div></div>

<p>For parsing I have mostly been using “recursive decent”, which basically means calling functions that parse different parse of your code recursively. But for parsing expressions with operator precedence, it means I will have to use a more complicated technique, which I am using called “Pratt Parsing”. I used this <a href="https://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/">blog post</a> which explains it.</p>

<p>We have to assign a precedence or “binding power” to each operator or symbol. Anything not in this Map will have a binding power of 0, meaning it won’t be added to any expression.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">precedences</span><span class="p">:</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="nx">Token</span><span class="p">[</span><span class="dl">"</span><span class="s2">type</span><span class="dl">"</span><span class="p">],</span> <span class="kr">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">([</span>
    <span class="p">[</span><span class="dl">"</span><span class="s2">+</span><span class="dl">"</span><span class="p">,</span> <span class="mi">60</span><span class="p">],</span>
    <span class="p">[</span><span class="dl">"</span><span class="s2">-</span><span class="dl">"</span><span class="p">,</span> <span class="mi">60</span><span class="p">],</span>
    <span class="p">[</span><span class="dl">"</span><span class="s2">*</span><span class="dl">"</span><span class="p">,</span> <span class="mi">70</span><span class="p">],</span>
    <span class="p">[</span><span class="dl">"</span><span class="s2">/</span><span class="dl">"</span><span class="p">,</span> <span class="mi">70</span><span class="p">],</span>
    <span class="p">[</span><span class="dl">"</span><span class="s2">MOD</span><span class="dl">"</span><span class="p">,</span> <span class="mi">70</span><span class="p">],</span>
    <span class="p">[</span><span class="dl">"</span><span class="s2">=</span><span class="dl">"</span><span class="p">,</span> <span class="mi">40</span><span class="p">],</span>
    <span class="p">[</span><span class="dl">"</span><span class="s2">!=</span><span class="dl">"</span><span class="p">,</span> <span class="mi">40</span><span class="p">],</span>
    <span class="p">[</span><span class="dl">"</span><span class="s2">&gt;</span><span class="dl">"</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span>
    <span class="p">[</span><span class="dl">"</span><span class="s2">&lt;</span><span class="dl">"</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span>
    <span class="p">[</span><span class="dl">"</span><span class="s2">&gt;=</span><span class="dl">"</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span>
    <span class="p">[</span><span class="dl">"</span><span class="s2">&lt;=</span><span class="dl">"</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span>
    <span class="p">[</span><span class="dl">"</span><span class="s2">AND</span><span class="dl">"</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
    <span class="p">[</span><span class="dl">"</span><span class="s2">OR</span><span class="dl">"</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span>
    <span class="p">[</span><span class="dl">"</span><span class="s2">&lt;-</span><span class="dl">"</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
    <span class="p">[</span><span class="dl">"</span><span class="s2">(</span><span class="dl">"</span><span class="p">,</span> <span class="mi">80</span><span class="p">],</span>
    <span class="p">[</span><span class="dl">"</span><span class="s2">[</span><span class="dl">"</span><span class="p">,</span> <span class="mi">80</span><span class="p">],</span>
<span class="p">])</span>

<span class="kd">get</span> <span class="nx">nextPrecedence</span><span class="p">():</span> <span class="kr">number</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">next</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">precedences</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="kd">type</span><span class="p">)</span> <span class="o">||</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>So now we are ready to parse our example. We are on the first token, <code class="language-plaintext highlighter-rouge">x</code>. This is the full code of expression if it helps to follow along:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">expression</span><span class="p">(</span><span class="nx">minPrecToStop</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">isStatement</span><span class="p">:</span> <span class="nx">boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="p">):</span> <span class="nx">Expression</span> <span class="o">|</span> <span class="p">(</span><span class="nx">Statement</span> <span class="o">&amp;</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">assign</span><span class="dl">"</span> <span class="p">})</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">primary</span><span class="p">(</span><span class="nx">isStatement</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="nx">minPrecToStop</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">nextPrecedence</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">token</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">consume</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">token</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

        <span class="kd">const</span> <span class="nx">op</span> <span class="o">=</span> <span class="nx">operators</span><span class="p">.</span><span class="nx">find</span><span class="p">((</span><span class="nx">x</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">===</span> <span class="nx">token</span><span class="p">.</span><span class="kd">type</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">op</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// a regular operator</span>
            <span class="kd">const</span> <span class="nx">rhs</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">expression</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">precedences</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">op</span><span class="p">)</span> <span class="o">||</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
            <span class="nx">result</span> <span class="o">=</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">operator</span><span class="dl">"</span><span class="p">,</span> <span class="na">operator</span><span class="p">:</span> <span class="nx">op</span><span class="p">,</span> <span class="na">lhs</span><span class="p">:</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">rhs</span> <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">(</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">paramaters</span> <span class="o">=</span> <span class="p">[];</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="nx">accept</span><span class="p">(</span><span class="dl">"</span><span class="s2">)</span><span class="dl">"</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">do</span> <span class="p">{</span>
                    <span class="nx">paramaters</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">expression</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
                <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">accept</span><span class="p">(</span><span class="dl">"</span><span class="s2">,</span><span class="dl">"</span><span class="p">));</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">expect</span><span class="p">(</span><span class="dl">"</span><span class="s2">)</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Expected ')' to end paramater list</span><span class="dl">"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nx">result</span> <span class="o">=</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">call</span><span class="dl">"</span><span class="p">,</span> <span class="na">procedure</span><span class="p">:</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">paramaters</span> <span class="p">};</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">[</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">index</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">expression</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">expect</span><span class="p">(</span><span class="dl">"</span><span class="s2">]</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Expected a ']' to close the list</span><span class="dl">"</span><span class="p">);</span>
            <span class="nx">result</span> <span class="o">=</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">subscript</span><span class="dl">"</span><span class="p">,</span> <span class="na">list</span><span class="p">:</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">index</span> <span class="p">};</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">token</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">&lt;-</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">isStatement</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">isAssignable</span><span class="p">(</span><span class="nx">result</span><span class="p">))</span> <span class="k">throw</span> <span class="k">new</span> <span class="nx">ParseError</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">location</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Can only assign to a variable or list item</span><span class="dl">"</span><span class="p">);</span>
                <span class="k">return</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">assign</span><span class="dl">"</span><span class="p">,</span> <span class="na">lhs</span><span class="p">:</span> <span class="nx">result</span><span class="p">,</span> <span class="na">rhs</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">expression</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">};</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nx">ParseError</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">location</span><span class="p">,</span> <span class="dl">"</span><span class="s2">Assignment must be a statement</span><span class="dl">"</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Whenever we start parsing an expression, we call <code class="language-plaintext highlighter-rouge">this.primary()</code>, which handles variables, literals, lists, and expressions in parentheses. In this case, it gives us just the variable <code class="language-plaintext highlighter-rouge">x</code>.</p>

<p>Next we see the <code class="language-plaintext highlighter-rouge">[</code>. This has a binding power of 80 (the highest it goes), but we wouldn’t stop anyway, since we will only if we find something with 0 binding power (the start of the next statement, which would probably be a keyword or variable).</p>

<p>When we see the <code class="language-plaintext highlighter-rouge">[</code>, it means it’s a subscript and we need the index. So we recurseivly call <code class="language-plaintext highlighter-rouge">this.expression(0)</code> to get the inside expression.</p>

<p>Now back at the start, we get a <code class="language-plaintext highlighter-rouge">this.primary()</code>. This is just the number 3. The next token is <code class="language-plaintext highlighter-rouge">]</code>, which has 0 binding power since it’s not in the map. So we just return the number 3.</p>

<p>Back outside, we remember we are parsing a list subscript, so we eat the <code class="language-plaintext highlighter-rouge">]</code>. Our result is now the subscript expression, with list: the variable x (remember this was our <code class="language-plaintext highlighter-rouge">result</code> from earlier), and with index: the number 3.</p>

<p>The next token is <code class="language-plaintext highlighter-rouge">&lt;-</code>, which has 10 binding power, so we are going to add it on to our current expression. We are going back through the while loop.</p>

<p>We are going to recurse <code class="language-plaintext highlighter-rouge">this.expression(0)</code> to get the right side of the assignment. We also check that our expression on the left is assignable, which it is.</p>

<p>Now back at the top of <code class="language-plaintext highlighter-rouge">expression</code>, we get a primary (the other number 3). Our next token is a <code class="language-plaintext highlighter-rouge">*</code>, so go into the <code class="language-plaintext highlighter-rouge">if (op)</code>. The rhs is yet another call to <code class="language-plaintext highlighter-rouge">expression</code>, but this time we give it a <code class="language-plaintext highlighter-rouge">minPrecToStop</code>. We don’t want it to eat the rest of the expression, which would give us <code class="language-plaintext highlighter-rouge">3*(y+f(a,b))</code>. We want it to stop if it gets to anything with less binding power than <code class="language-plaintext highlighter-rouge">*</code>. Therefore, we look up the precedence for <code class="language-plaintext highlighter-rouge">*</code>, which is 70. We will stop if we get to anything with less precedence than 70.</p>

<p>So we get a <code class="language-plaintext highlighter-rouge">this.primary()</code>, which is the variable <code class="language-plaintext highlighter-rouge">y.</code> But now the next precedence is for <code class="language-plaintext highlighter-rouge">+</code>, which is only 60. So we stop and return. The rhs of the multiplication is only <code class="language-plaintext highlighter-rouge">y</code>, not <code class="language-plaintext highlighter-rouge">y+f(a,b)</code>, because we stop at the <code class="language-plaintext highlighter-rouge">+</code>.</p>

<p>Now we are back out into parsing the right side of the assignment. We are going to keep parsing the rest of the expression (<code class="language-plaintext highlighter-rouge">minPrecToStop = 0</code>), so we take the plus. We call <code class="language-plaintext highlighter-rouge">this.expression</code> with <code class="language-plaintext highlighter-rouge">minPrecToStop</code> of 60, although that won’t matter in this case.</p>

<p>We get a primary (<code class="language-plaintext highlighter-rouge">f</code>). Then it’s a <code class="language-plaintext highlighter-rouge">(</code>. Binding power let’s us handle function calls as well as operators. So we get the arguments until we run out of commas. All of the calls to <code class="language-plaintext highlighter-rouge">this.expression(0)</code> will stop at the comma, since comma has 0 binding power. Then we take the <code class="language-plaintext highlighter-rouge">)</code>, create the function call ast, and it onto our <code class="language-plaintext highlighter-rouge">3*y</code></p>

<p>Now there’s no way anything could eat anymore, so we’re done.</p>

      </div>

        <!-- Configure Disqus --></div>
  </main></body>
</html>