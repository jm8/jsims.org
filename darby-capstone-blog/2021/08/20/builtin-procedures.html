<!DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link href="https://fonts.googleapis.com/css?family=Nunito+Sans:400,400i,700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="/darby-capstone-blog/assets/css/style.css">
<title>Builtin Procedures</title>
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Builtin Procedures</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Builtin Procedures" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Next I want to add the interactivity, with DISPLAY and AWAIT. These will both be “builtin” procedures, so I am adding this to the Value. | { type: &quot;procedure&quot;, builtin: true, call(ast: Ast &amp; { type: &quot;call&quot; }, params: Value[]): Promise&lt;Value&gt; } For now, all procedures will be builtin, as I have not added user-defined procedures. So I just have to define what to do on an INPUT or DISPLAY. I have decided to require callback functions, onDisplay(x: Value): Promise&lt;void&gt; and onWaitForInput(): Promise&lt;string&gt; which will be called whenever these functions are called. We just take them in the constructor. Also, we are going to add these procedures to the globals map. INPUT trys to turn the input into a number, but leaves it as a string if it can’t. constructor(callbacks: InterpreterCallbacks) { this.callbacks = callbacks; this.globals = new Map(); this.globals.set(&quot;DISPLAY&quot;, { type: &quot;procedure&quot;, builtin: true, call: (async (ast: Ast&lt;Annotations&gt;, params: Value[]) =&gt; { if (params.length !== 1) { this.error(ast, &quot;DISPLAY takes 1 argument&quot;); } await this.callbacks.onDisplay(cloneDeep(params[0])); return { type: &quot;void&quot; }; }) }) this.globals.set(&quot;INPUT&quot;, { type: &quot;procedure&quot;, builtin: true, call: (async (ast: Ast&lt;Annotations&gt;, params: Value[]) =&gt; { if (params.length !== 0) { this.error(ast, &quot;INPUT takes no arguments&quot;); } const inputString = await this.callbacks.onWaitForInput(); const num = Number(inputString); if (isNaN(num)) { return { type: &quot;string&quot;, value: inputString } } else { return { type: &quot;number&quot;, value: num }; } }) }) } Now we have to make it interpret calls: // evaluate // ... } else if (ast.type === &quot;call&quot;) { const procedure = await this.expectType(ast.procedure, &quot;procedure&quot;) let paramaters: Value[] = []; for (const item of ast.paramaters) { paramaters.push(await this.evaluate(item)); } // we need to pass the ast so it can set &#39;error&#39; flag return await procedure.call(ast, paramaters); } // ... Of course, we are going to have to provide those callbacks so we can make it appear on the screen. onDisplay is the simple one, all it has to do is record the new value that was displayed, so we can put it on the screen. export type ConsoleLine = { type: &quot;input&quot;, value: string } | { type: &quot;display&quot;, value: Value } const [consoleLines, setConsoleLines] = useState&lt;ConsoleLine[]&gt;([]); async onDisplay(x: Value) { setConsoleLines(old =&gt; [...old, { type: &quot;display&quot;, value: x }]) } onWaitForInput is more complicated. We have to return a Promise that will only be resolved when input is actually given. So we set the onInput function so it will resolve that Promise, and call it when the user actually types something. type OnInput = ((x: string) =&gt; void) | null; const [onInput, setOnInput] = useState&lt;OnInput&gt;(null); onWaitForInput() { return new Promise&lt;string&gt;(resolve =&gt; { setOnInput((oldOnInput: OnInput) =&gt; (x: string) =&gt; { setConsoleLines(old =&gt; [...old, { type: &quot;input&quot;, value: x }]); setOnInput(null); resolve(x); }) }) }, One of the problems I had was passing a function to setOnInput (which is from React useState hook). When you give setState a function, it tries to call that function with the old value (like in setConsoleLines above). This is useful to avoid “stale closures”, because if we just did setConsoleLines([...consoleLines, x]), it would be stuck with the value of consoleLines from when we first made that closure, which was way back when the code first started being interpreted. However, it just means that when I want to set onInput, I have to do it like setOnInput(_ =&gt; newValue), not setOnInput(newValue). Anyway, now we can do INPUT and DISPLAY and actually make programs that do cool things. Other procedures, APPEND, LENGTH, RANDOM, etc. are a lot easier. Like here is APPEND: this.globals.set(&quot;APPEND&quot;, { type: &quot;procedure&quot;, builtin: true, call: (async (ast: Ast &amp; { type: &quot;call&quot; }, params: Value[]) =&gt; { if (params.length !== 2) { this.error(ast, &quot;APPEND takes 2 arguments&quot;); } if (params[0].type !== &quot;list&quot;) { this.error(ast.paramaters[0], &quot;must be a list&quot;); } params[0].value.push(params[1]); return { type: &quot;void&quot; }; }) }) Mostly just error checking, the actual code is really simple. And now the language is basically complete, except for user-defined procedures." />
<meta property="og:description" content="Next I want to add the interactivity, with DISPLAY and AWAIT. These will both be “builtin” procedures, so I am adding this to the Value. | { type: &quot;procedure&quot;, builtin: true, call(ast: Ast &amp; { type: &quot;call&quot; }, params: Value[]): Promise&lt;Value&gt; } For now, all procedures will be builtin, as I have not added user-defined procedures. So I just have to define what to do on an INPUT or DISPLAY. I have decided to require callback functions, onDisplay(x: Value): Promise&lt;void&gt; and onWaitForInput(): Promise&lt;string&gt; which will be called whenever these functions are called. We just take them in the constructor. Also, we are going to add these procedures to the globals map. INPUT trys to turn the input into a number, but leaves it as a string if it can’t. constructor(callbacks: InterpreterCallbacks) { this.callbacks = callbacks; this.globals = new Map(); this.globals.set(&quot;DISPLAY&quot;, { type: &quot;procedure&quot;, builtin: true, call: (async (ast: Ast&lt;Annotations&gt;, params: Value[]) =&gt; { if (params.length !== 1) { this.error(ast, &quot;DISPLAY takes 1 argument&quot;); } await this.callbacks.onDisplay(cloneDeep(params[0])); return { type: &quot;void&quot; }; }) }) this.globals.set(&quot;INPUT&quot;, { type: &quot;procedure&quot;, builtin: true, call: (async (ast: Ast&lt;Annotations&gt;, params: Value[]) =&gt; { if (params.length !== 0) { this.error(ast, &quot;INPUT takes no arguments&quot;); } const inputString = await this.callbacks.onWaitForInput(); const num = Number(inputString); if (isNaN(num)) { return { type: &quot;string&quot;, value: inputString } } else { return { type: &quot;number&quot;, value: num }; } }) }) } Now we have to make it interpret calls: // evaluate // ... } else if (ast.type === &quot;call&quot;) { const procedure = await this.expectType(ast.procedure, &quot;procedure&quot;) let paramaters: Value[] = []; for (const item of ast.paramaters) { paramaters.push(await this.evaluate(item)); } // we need to pass the ast so it can set &#39;error&#39; flag return await procedure.call(ast, paramaters); } // ... Of course, we are going to have to provide those callbacks so we can make it appear on the screen. onDisplay is the simple one, all it has to do is record the new value that was displayed, so we can put it on the screen. export type ConsoleLine = { type: &quot;input&quot;, value: string } | { type: &quot;display&quot;, value: Value } const [consoleLines, setConsoleLines] = useState&lt;ConsoleLine[]&gt;([]); async onDisplay(x: Value) { setConsoleLines(old =&gt; [...old, { type: &quot;display&quot;, value: x }]) } onWaitForInput is more complicated. We have to return a Promise that will only be resolved when input is actually given. So we set the onInput function so it will resolve that Promise, and call it when the user actually types something. type OnInput = ((x: string) =&gt; void) | null; const [onInput, setOnInput] = useState&lt;OnInput&gt;(null); onWaitForInput() { return new Promise&lt;string&gt;(resolve =&gt; { setOnInput((oldOnInput: OnInput) =&gt; (x: string) =&gt; { setConsoleLines(old =&gt; [...old, { type: &quot;input&quot;, value: x }]); setOnInput(null); resolve(x); }) }) }, One of the problems I had was passing a function to setOnInput (which is from React useState hook). When you give setState a function, it tries to call that function with the old value (like in setConsoleLines above). This is useful to avoid “stale closures”, because if we just did setConsoleLines([...consoleLines, x]), it would be stuck with the value of consoleLines from when we first made that closure, which was way back when the code first started being interpreted. However, it just means that when I want to set onInput, I have to do it like setOnInput(_ =&gt; newValue), not setOnInput(newValue). Anyway, now we can do INPUT and DISPLAY and actually make programs that do cool things. Other procedures, APPEND, LENGTH, RANDOM, etc. are a lot easier. Like here is APPEND: this.globals.set(&quot;APPEND&quot;, { type: &quot;procedure&quot;, builtin: true, call: (async (ast: Ast &amp; { type: &quot;call&quot; }, params: Value[]) =&gt; { if (params.length !== 2) { this.error(ast, &quot;APPEND takes 2 arguments&quot;); } if (params[0].type !== &quot;list&quot;) { this.error(ast.paramaters[0], &quot;must be a list&quot;); } params[0].value.push(params[1]); return { type: &quot;void&quot; }; }) }) Mostly just error checking, the actual code is really simple. And now the language is basically complete, except for user-defined procedures." />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-08-20T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Builtin Procedures" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"/darby-capstone-blog/2021/08/20/builtin-procedures.html"},"@type":"BlogPosting","description":"Next I want to add the interactivity, with DISPLAY and AWAIT. These will both be “builtin” procedures, so I am adding this to the Value. | { type: &quot;procedure&quot;, builtin: true, call(ast: Ast &amp; { type: &quot;call&quot; }, params: Value[]): Promise&lt;Value&gt; } For now, all procedures will be builtin, as I have not added user-defined procedures. So I just have to define what to do on an INPUT or DISPLAY. I have decided to require callback functions, onDisplay(x: Value): Promise&lt;void&gt; and onWaitForInput(): Promise&lt;string&gt; which will be called whenever these functions are called. We just take them in the constructor. Also, we are going to add these procedures to the globals map. INPUT trys to turn the input into a number, but leaves it as a string if it can’t. constructor(callbacks: InterpreterCallbacks) { this.callbacks = callbacks; this.globals = new Map(); this.globals.set(&quot;DISPLAY&quot;, { type: &quot;procedure&quot;, builtin: true, call: (async (ast: Ast&lt;Annotations&gt;, params: Value[]) =&gt; { if (params.length !== 1) { this.error(ast, &quot;DISPLAY takes 1 argument&quot;); } await this.callbacks.onDisplay(cloneDeep(params[0])); return { type: &quot;void&quot; }; }) }) this.globals.set(&quot;INPUT&quot;, { type: &quot;procedure&quot;, builtin: true, call: (async (ast: Ast&lt;Annotations&gt;, params: Value[]) =&gt; { if (params.length !== 0) { this.error(ast, &quot;INPUT takes no arguments&quot;); } const inputString = await this.callbacks.onWaitForInput(); const num = Number(inputString); if (isNaN(num)) { return { type: &quot;string&quot;, value: inputString } } else { return { type: &quot;number&quot;, value: num }; } }) }) } Now we have to make it interpret calls: // evaluate // ... } else if (ast.type === &quot;call&quot;) { const procedure = await this.expectType(ast.procedure, &quot;procedure&quot;) let paramaters: Value[] = []; for (const item of ast.paramaters) { paramaters.push(await this.evaluate(item)); } // we need to pass the ast so it can set &#39;error&#39; flag return await procedure.call(ast, paramaters); } // ... Of course, we are going to have to provide those callbacks so we can make it appear on the screen. onDisplay is the simple one, all it has to do is record the new value that was displayed, so we can put it on the screen. export type ConsoleLine = { type: &quot;input&quot;, value: string } | { type: &quot;display&quot;, value: Value } const [consoleLines, setConsoleLines] = useState&lt;ConsoleLine[]&gt;([]); async onDisplay(x: Value) { setConsoleLines(old =&gt; [...old, { type: &quot;display&quot;, value: x }]) } onWaitForInput is more complicated. We have to return a Promise that will only be resolved when input is actually given. So we set the onInput function so it will resolve that Promise, and call it when the user actually types something. type OnInput = ((x: string) =&gt; void) | null; const [onInput, setOnInput] = useState&lt;OnInput&gt;(null); onWaitForInput() { return new Promise&lt;string&gt;(resolve =&gt; { setOnInput((oldOnInput: OnInput) =&gt; (x: string) =&gt; { setConsoleLines(old =&gt; [...old, { type: &quot;input&quot;, value: x }]); setOnInput(null); resolve(x); }) }) }, One of the problems I had was passing a function to setOnInput (which is from React useState hook). When you give setState a function, it tries to call that function with the old value (like in setConsoleLines above). This is useful to avoid “stale closures”, because if we just did setConsoleLines([...consoleLines, x]), it would be stuck with the value of consoleLines from when we first made that closure, which was way back when the code first started being interpreted. However, it just means that when I want to set onInput, I have to do it like setOnInput(_ =&gt; newValue), not setOnInput(newValue). Anyway, now we can do INPUT and DISPLAY and actually make programs that do cool things. Other procedures, APPEND, LENGTH, RANDOM, etc. are a lot easier. Like here is APPEND: this.globals.set(&quot;APPEND&quot;, { type: &quot;procedure&quot;, builtin: true, call: (async (ast: Ast &amp; { type: &quot;call&quot; }, params: Value[]) =&gt; { if (params.length !== 2) { this.error(ast, &quot;APPEND takes 2 arguments&quot;); } if (params[0].type !== &quot;list&quot;) { this.error(ast.paramaters[0], &quot;must be a list&quot;); } params[0].value.push(params[1]); return { type: &quot;void&quot; }; }) }) Mostly just error checking, the actual code is really simple. And now the language is basically complete, except for user-defined procedures.","headline":"Builtin Procedures","dateModified":"2021-08-20T00:00:00-04:00","datePublished":"2021-08-20T00:00:00-04:00","url":"/darby-capstone-blog/2021/08/20/builtin-procedures.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
</head>
<body>
  <header class="texture-red">
    <div class="container"><div class="navbar">
	<ul>
		
		<a href="/"><li  >About</li></a>
		
		<a href="/expectations"><li  >Expectations</li></a>
		
		<a href="/experience"><li  >Experience</li></a>
		
		<a href="/mentor"><li  >Mentor</li></a>
		
		<a href="/interview"><li  >Interview</li></a>
		
		<a href="/reflection"><li  >Reflection</li></a>
		
		<a href="https://jsims.org/apcsp"><li  >Run my Project</li></a>
		
	</ul>
</div></div><div class="container">
	<h1>Builtin Procedures</h1>
	<h4 class="post-description"></h4>
	<div class="post-date" style="margin-top:20px">
		Published on Aug 20, 2021
	</div>
	<ul class="post-tags"></ul>
</div>
</header>
  <main>
    <div class="container">
      <div class="post-container">
          <p>Next I want to add the interactivity, with DISPLAY and AWAIT. These will both be “builtin” procedures,
so I am adding this to the <code class="language-plaintext highlighter-rouge">Value</code>.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">procedure</span><span class="dl">"</span><span class="p">,</span> <span class="na">builtin</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">call</span><span class="p">(</span><span class="na">ast</span><span class="p">:</span> <span class="nx">Ast</span> <span class="o">&amp;</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">call</span><span class="dl">"</span> <span class="p">},</span> <span class="na">params</span><span class="p">:</span> <span class="nx">Value</span><span class="p">[]):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">Value</span><span class="o">&gt;</span> <span class="p">}</span>
</code></pre></div></div>

<p>For now, all procedures will be builtin, as I have not added user-defined procedures.</p>

<p>So I just have to define what to do on an <code class="language-plaintext highlighter-rouge">INPUT</code> or <code class="language-plaintext highlighter-rouge">DISPLAY</code>.</p>

<p>I have decided to require callback functions, <code class="language-plaintext highlighter-rouge">onDisplay(x: Value): Promise&lt;void&gt;</code> and <code class="language-plaintext highlighter-rouge">onWaitForInput(): Promise&lt;string&gt;</code> which will be called whenever these functions are called. We just take them in the constructor. Also, we are going to add these procedures to the <code class="language-plaintext highlighter-rouge">globals</code> map.</p>

<p><code class="language-plaintext highlighter-rouge">INPUT</code> trys to turn the input into a number, but leaves it as a string if it can’t.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">constructor</span><span class="p">(</span><span class="nx">callbacks</span><span class="p">:</span> <span class="nx">InterpreterCallbacks</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">callbacks</span> <span class="o">=</span> <span class="nx">callbacks</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">globals</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">globals</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">"</span><span class="s2">DISPLAY</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
        <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">procedure</span><span class="dl">"</span><span class="p">,</span>
        <span class="na">builtin</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">call</span><span class="p">:</span> <span class="p">(</span><span class="k">async</span> <span class="p">(</span><span class="na">ast</span><span class="p">:</span> <span class="nx">Ast</span><span class="o">&lt;</span><span class="nx">Annotations</span><span class="o">&gt;</span><span class="p">,</span> <span class="na">params</span><span class="p">:</span> <span class="nx">Value</span><span class="p">[])</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">params</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">ast</span><span class="p">,</span> <span class="dl">"</span><span class="s2">DISPLAY takes 1 argument</span><span class="dl">"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">onDisplay</span><span class="p">(</span><span class="nx">cloneDeep</span><span class="p">(</span><span class="nx">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
            <span class="k">return</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">void</span><span class="dl">"</span> <span class="p">};</span>
        <span class="p">})</span>
    <span class="p">})</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">globals</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">"</span><span class="s2">INPUT</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
        <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">procedure</span><span class="dl">"</span><span class="p">,</span>
        <span class="na">builtin</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
        <span class="na">call</span><span class="p">:</span> <span class="p">(</span><span class="k">async</span> <span class="p">(</span><span class="na">ast</span><span class="p">:</span> <span class="nx">Ast</span><span class="o">&lt;</span><span class="nx">Annotations</span><span class="o">&gt;</span><span class="p">,</span> <span class="na">params</span><span class="p">:</span> <span class="nx">Value</span><span class="p">[])</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">params</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">this</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">ast</span><span class="p">,</span> <span class="dl">"</span><span class="s2">INPUT takes no arguments</span><span class="dl">"</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="kd">const</span> <span class="nx">inputString</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">callbacks</span><span class="p">.</span><span class="nx">onWaitForInput</span><span class="p">();</span>
            <span class="kd">const</span> <span class="nx">num</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="nx">inputString</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isNaN</span><span class="p">(</span><span class="nx">num</span><span class="p">))</span> <span class="p">{</span>
                <span class="k">return</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">inputString</span> <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">num</span> <span class="p">};</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">})</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now we have to make it interpret calls:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// evaluate</span>
<span class="c1">// ...</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">call</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">procedure</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">expectType</span><span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">procedure</span><span class="p">,</span> <span class="dl">"</span><span class="s2">procedure</span><span class="dl">"</span><span class="p">)</span>
    <span class="kd">let</span> <span class="nx">paramaters</span><span class="p">:</span> <span class="nx">Value</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">ast</span><span class="p">.</span><span class="nx">paramaters</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">paramaters</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">evaluate</span><span class="p">(</span><span class="nx">item</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="c1">// we need to pass the ast so it can set 'error' flag</span>
    <span class="k">return</span> <span class="k">await</span> <span class="nx">procedure</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">ast</span><span class="p">,</span> <span class="nx">paramaters</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// ...</span>
</code></pre></div></div>

<p>Of course, we are going to have to provide those callbacks so we can make it appear on the screen.</p>

<p><code class="language-plaintext highlighter-rouge">onDisplay</code> is the simple one, all it has to do is record the new value that was displayed, so we can put it on the screen.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">type</span> <span class="nx">ConsoleLine</span> <span class="o">=</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">input</span><span class="dl">"</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="kr">string</span> <span class="p">}</span> <span class="o">|</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">display</span><span class="dl">"</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">Value</span> <span class="p">}</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">consoleLines</span><span class="p">,</span> <span class="nx">setConsoleLines</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="o">&lt;</span><span class="nx">ConsoleLine</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">([]);</span>
<span class="k">async</span> <span class="nx">onDisplay</span><span class="p">(</span><span class="nx">x</span><span class="p">:</span> <span class="nx">Value</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">setConsoleLines</span><span class="p">(</span><span class="nx">old</span> <span class="o">=&gt;</span> <span class="p">[...</span><span class="nx">old</span><span class="p">,</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">display</span><span class="dl">"</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">x</span> <span class="p">}])</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">onWaitForInput</code> is more complicated. We have to return a Promise that will only be resolved when input is actually given. So we set the <code class="language-plaintext highlighter-rouge">onInput</code> function so it will resolve that Promise, and call it when the user actually types something.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">OnInput</span> <span class="o">=</span> <span class="p">((</span><span class="nx">x</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">)</span> <span class="o">|</span> <span class="kc">null</span><span class="p">;</span>
<span class="kd">const</span> <span class="p">[</span><span class="nx">onInput</span><span class="p">,</span> <span class="nx">setOnInput</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="o">&lt;</span><span class="nx">OnInput</span><span class="o">&gt;</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="nx">onWaitForInput</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">setOnInput</span><span class="p">((</span><span class="na">oldOnInput</span><span class="p">:</span> <span class="nx">OnInput</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="na">x</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
            <span class="nx">setConsoleLines</span><span class="p">(</span><span class="nx">old</span> <span class="o">=&gt;</span> <span class="p">[...</span><span class="nx">old</span><span class="p">,</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">input</span><span class="dl">"</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">x</span> <span class="p">}]);</span>
            <span class="nx">setOnInput</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
            <span class="nx">resolve</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
        <span class="p">})</span>
    <span class="p">})</span>
<span class="p">},</span>
</code></pre></div></div>

<p>One of the problems I had was passing a function to <code class="language-plaintext highlighter-rouge">setOnInput</code> (which is from React <code class="language-plaintext highlighter-rouge">useState</code> hook). When you give <code class="language-plaintext highlighter-rouge">setState</code> a function, it tries to call that function with the old value (like in <code class="language-plaintext highlighter-rouge">setConsoleLines</code> above). This is useful to avoid “stale closures”, because if we just did <code class="language-plaintext highlighter-rouge">setConsoleLines([...consoleLines, x])</code>, it would be stuck with the value of <code class="language-plaintext highlighter-rouge">consoleLines</code> from when we first made that closure, which was way back when the code first started being interpreted. However, it just means that when I want to set <code class="language-plaintext highlighter-rouge">onInput</code>, I have to do it like <code class="language-plaintext highlighter-rouge">setOnInput(_ =&gt; newValue)</code>, not <code class="language-plaintext highlighter-rouge">setOnInput(newValue)</code>.</p>

<p>Anyway, now we can do <code class="language-plaintext highlighter-rouge">INPUT</code> and <code class="language-plaintext highlighter-rouge">DISPLAY</code> and actually make programs that do cool things.</p>

<p>Other procedures, <code class="language-plaintext highlighter-rouge">APPEND</code>, <code class="language-plaintext highlighter-rouge">LENGTH</code>, <code class="language-plaintext highlighter-rouge">RANDOM</code>, etc. are a lot easier. Like here is APPEND:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">this</span><span class="p">.</span><span class="nx">globals</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">"</span><span class="s2">APPEND</span><span class="dl">"</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">procedure</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">builtin</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
    <span class="na">call</span><span class="p">:</span> <span class="p">(</span><span class="k">async</span> <span class="p">(</span><span class="na">ast</span><span class="p">:</span> <span class="nx">Ast</span> <span class="o">&amp;</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">call</span><span class="dl">"</span> <span class="p">},</span> <span class="na">params</span><span class="p">:</span> <span class="nx">Value</span><span class="p">[])</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">params</span><span class="p">.</span><span class="nx">length</span> <span class="o">!==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">ast</span><span class="p">,</span> <span class="dl">"</span><span class="s2">APPEND takes 2 arguments</span><span class="dl">"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">params</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="kd">type</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">list</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">paramaters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="dl">"</span><span class="s2">must be a list</span><span class="dl">"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nx">params</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">value</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

        <span class="k">return</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">void</span><span class="dl">"</span> <span class="p">};</span>
    <span class="p">})</span>
<span class="p">})</span>
</code></pre></div></div>

<p>Mostly just error checking, the actual code is really simple. And now the language is basically complete, except for user-defined procedures.</p>

      </div>

        <!-- Configure Disqus --></div>
  </main></body>
</html>