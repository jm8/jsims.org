<!DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link href="https://fonts.googleapis.com/css?family=Nunito+Sans:400,400i,700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="/darby-capstone-blog/assets/css/style.css">
<title>Tokenizer</title>
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Tokenizer</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Tokenizer" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I want to parse my expressions into an AST, but first it is good to make a “tokenizer”. When you are parsing, it is a lot easier to say “there should be a number here”, without worrying about the individual digits and characters that make up the number. So we turn it into tokens, like number or + or variable. For example, for the expression (myvariable + 1) * 50, which is really a sequence of characters like [&#39;(&#39;, &#39;m&#39;, &#39;y&#39;, &#39;v&#39;, &#39;a&#39;, &#39;r&#39;, &#39;i&#39;, &#39;a&#39;, &#39;b&#39;, &#39;l&#39;, &#39;e&#39;, &#39; &#39;, &#39;+&#39;, &#39; &#39;, &#39;1&#39;, &#39;)&#39;, &#39; &#39;, &#39;*&#39;, &#39; &#39;, &#39;5&#39;, &#39;0&#39;] The tokenizer will turn it into [ { type: &#39;(&#39; }, { type: &#39;variable&#39;, name: &#39;myvariable&#39; }, { type: &#39;+&#39; }, { type: &#39;number&#39;, value: 1 }, { type: &#39;)&#39; }, { type: &#39;*&#39; }, { type: &#39;number&#39;, value: 50 } ] Notice that this does not include any nested structure like our AST. It is still a sequence of things. However, the whitespace is gone, and things that are one “token” like an individual variable or number are together. The parser would then use these tokens to turn it into { type: &quot;operator&quot;, operator: &quot;*&quot;, lhs: { type: &quot;operator&quot;, operator: &quot;+&quot; lhs: { type: &quot;variable&quot;, name: &quot;myvariable&quot;, }, rhs: { type: &quot;number&quot;, value: 1 } }, rhs: { type: &quot;number&quot;, value: 50 } } The technique I will use to create the tokenizer is regular expressions. These are things which match certain strings. The regex /^\s+/ is pretty simple, it matches some amount of whitespace (for us to skip). /^[a-zA-Z_][a-zA-Z_0-9]*/ matches identifiers (variable names), which must start with a letter or underscore, then have some amount of letters, underscores, or digits (the * means 0 or more, + means 1 or more.) /^[0-9]*\.?[0-9]+/ is complicated, but it matches numbers. These can have possibly some digits, maybe a decimal point, and must always end with 1 or more digit. This lets us have all sorts of numbers, like .5, 6.3, and 12. We need the ^ at the beginning because that means it match match at the start of the string. We don’t want our regex to be finding things that happen later on than we are looking. The tokenizer keeps checking if the code matches any of these regular expressions, or if it matches a symbol. I check for symbols kind of like this: const operators = [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;, &quot;MOD&quot; , &quot;=&quot;, &quot;!=&quot;, &quot;&gt;&quot;, &quot;&lt;&quot;, &quot;&gt;=&quot;, &quot;&lt;=&quot; , &quot;AND&quot;, &quot;OR&quot;]; const symbols = [&quot;{&quot;, &quot;}&quot;, &quot;[&quot;, &quot;]&quot;, &quot;(&quot;, &quot;)&quot;, &quot;&lt;-&quot;, &quot;,&quot;]; const symbolsSorted = [...operators, ...symbols].sort((a, b) =&gt; b.length - a.length) for (const sym of symbolsSorted) { if (remainder.startsWith(sym)) return { newRemainder: remainder.slice(sym.length), token: { type: sym } }; } I have to check longer symbols first, because &lt;- starts with both &lt; and &lt;-, but we want it to say it’s &lt;- (the assignment arrow), and not a less than sign. This is how I make the firstToken function. If we want all the tokens, I made a simple function that gets them all. It also keeps track of the location in the code: export function tokenize(code: string): (Token &amp; { location: Location })[] { let remainder = code; let result = []; let location = { line: 1, col: 1 }; while (!remainder.match(/^\s*$/)) { const { text, token, whitespace } = firstToken(remainder); remainder = remainder.slice(text.length + whitespace.length); for (const c of whitespace) { if (c === &quot;\n&quot;) { location.col = 1; location.line++; } else { location.col++; } } for (const c of text) { if (c === &quot;\n&quot;) { location.col = 1; location.line++; } else { location.col++; } } result.push({ ...token, location }); } return result; }" />
<meta property="og:description" content="I want to parse my expressions into an AST, but first it is good to make a “tokenizer”. When you are parsing, it is a lot easier to say “there should be a number here”, without worrying about the individual digits and characters that make up the number. So we turn it into tokens, like number or + or variable. For example, for the expression (myvariable + 1) * 50, which is really a sequence of characters like [&#39;(&#39;, &#39;m&#39;, &#39;y&#39;, &#39;v&#39;, &#39;a&#39;, &#39;r&#39;, &#39;i&#39;, &#39;a&#39;, &#39;b&#39;, &#39;l&#39;, &#39;e&#39;, &#39; &#39;, &#39;+&#39;, &#39; &#39;, &#39;1&#39;, &#39;)&#39;, &#39; &#39;, &#39;*&#39;, &#39; &#39;, &#39;5&#39;, &#39;0&#39;] The tokenizer will turn it into [ { type: &#39;(&#39; }, { type: &#39;variable&#39;, name: &#39;myvariable&#39; }, { type: &#39;+&#39; }, { type: &#39;number&#39;, value: 1 }, { type: &#39;)&#39; }, { type: &#39;*&#39; }, { type: &#39;number&#39;, value: 50 } ] Notice that this does not include any nested structure like our AST. It is still a sequence of things. However, the whitespace is gone, and things that are one “token” like an individual variable or number are together. The parser would then use these tokens to turn it into { type: &quot;operator&quot;, operator: &quot;*&quot;, lhs: { type: &quot;operator&quot;, operator: &quot;+&quot; lhs: { type: &quot;variable&quot;, name: &quot;myvariable&quot;, }, rhs: { type: &quot;number&quot;, value: 1 } }, rhs: { type: &quot;number&quot;, value: 50 } } The technique I will use to create the tokenizer is regular expressions. These are things which match certain strings. The regex /^\s+/ is pretty simple, it matches some amount of whitespace (for us to skip). /^[a-zA-Z_][a-zA-Z_0-9]*/ matches identifiers (variable names), which must start with a letter or underscore, then have some amount of letters, underscores, or digits (the * means 0 or more, + means 1 or more.) /^[0-9]*\.?[0-9]+/ is complicated, but it matches numbers. These can have possibly some digits, maybe a decimal point, and must always end with 1 or more digit. This lets us have all sorts of numbers, like .5, 6.3, and 12. We need the ^ at the beginning because that means it match match at the start of the string. We don’t want our regex to be finding things that happen later on than we are looking. The tokenizer keeps checking if the code matches any of these regular expressions, or if it matches a symbol. I check for symbols kind of like this: const operators = [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;, &quot;MOD&quot; , &quot;=&quot;, &quot;!=&quot;, &quot;&gt;&quot;, &quot;&lt;&quot;, &quot;&gt;=&quot;, &quot;&lt;=&quot; , &quot;AND&quot;, &quot;OR&quot;]; const symbols = [&quot;{&quot;, &quot;}&quot;, &quot;[&quot;, &quot;]&quot;, &quot;(&quot;, &quot;)&quot;, &quot;&lt;-&quot;, &quot;,&quot;]; const symbolsSorted = [...operators, ...symbols].sort((a, b) =&gt; b.length - a.length) for (const sym of symbolsSorted) { if (remainder.startsWith(sym)) return { newRemainder: remainder.slice(sym.length), token: { type: sym } }; } I have to check longer symbols first, because &lt;- starts with both &lt; and &lt;-, but we want it to say it’s &lt;- (the assignment arrow), and not a less than sign. This is how I make the firstToken function. If we want all the tokens, I made a simple function that gets them all. It also keeps track of the location in the code: export function tokenize(code: string): (Token &amp; { location: Location })[] { let remainder = code; let result = []; let location = { line: 1, col: 1 }; while (!remainder.match(/^\s*$/)) { const { text, token, whitespace } = firstToken(remainder); remainder = remainder.slice(text.length + whitespace.length); for (const c of whitespace) { if (c === &quot;\n&quot;) { location.col = 1; location.line++; } else { location.col++; } } for (const c of text) { if (c === &quot;\n&quot;) { location.col = 1; location.line++; } else { location.col++; } } result.push({ ...token, location }); } return result; }" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-08-09T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Tokenizer" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"/darby-capstone-blog/2021/08/09/tokenizer.html"},"@type":"BlogPosting","description":"I want to parse my expressions into an AST, but first it is good to make a “tokenizer”. When you are parsing, it is a lot easier to say “there should be a number here”, without worrying about the individual digits and characters that make up the number. So we turn it into tokens, like number or + or variable. For example, for the expression (myvariable + 1) * 50, which is really a sequence of characters like [&#39;(&#39;, &#39;m&#39;, &#39;y&#39;, &#39;v&#39;, &#39;a&#39;, &#39;r&#39;, &#39;i&#39;, &#39;a&#39;, &#39;b&#39;, &#39;l&#39;, &#39;e&#39;, &#39; &#39;, &#39;+&#39;, &#39; &#39;, &#39;1&#39;, &#39;)&#39;, &#39; &#39;, &#39;*&#39;, &#39; &#39;, &#39;5&#39;, &#39;0&#39;] The tokenizer will turn it into [ { type: &#39;(&#39; }, { type: &#39;variable&#39;, name: &#39;myvariable&#39; }, { type: &#39;+&#39; }, { type: &#39;number&#39;, value: 1 }, { type: &#39;)&#39; }, { type: &#39;*&#39; }, { type: &#39;number&#39;, value: 50 } ] Notice that this does not include any nested structure like our AST. It is still a sequence of things. However, the whitespace is gone, and things that are one “token” like an individual variable or number are together. The parser would then use these tokens to turn it into { type: &quot;operator&quot;, operator: &quot;*&quot;, lhs: { type: &quot;operator&quot;, operator: &quot;+&quot; lhs: { type: &quot;variable&quot;, name: &quot;myvariable&quot;, }, rhs: { type: &quot;number&quot;, value: 1 } }, rhs: { type: &quot;number&quot;, value: 50 } } The technique I will use to create the tokenizer is regular expressions. These are things which match certain strings. The regex /^\\s+/ is pretty simple, it matches some amount of whitespace (for us to skip). /^[a-zA-Z_][a-zA-Z_0-9]*/ matches identifiers (variable names), which must start with a letter or underscore, then have some amount of letters, underscores, or digits (the * means 0 or more, + means 1 or more.) /^[0-9]*\\.?[0-9]+/ is complicated, but it matches numbers. These can have possibly some digits, maybe a decimal point, and must always end with 1 or more digit. This lets us have all sorts of numbers, like .5, 6.3, and 12. We need the ^ at the beginning because that means it match match at the start of the string. We don’t want our regex to be finding things that happen later on than we are looking. The tokenizer keeps checking if the code matches any of these regular expressions, or if it matches a symbol. I check for symbols kind of like this: const operators = [&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;, &quot;MOD&quot; , &quot;=&quot;, &quot;!=&quot;, &quot;&gt;&quot;, &quot;&lt;&quot;, &quot;&gt;=&quot;, &quot;&lt;=&quot; , &quot;AND&quot;, &quot;OR&quot;]; const symbols = [&quot;{&quot;, &quot;}&quot;, &quot;[&quot;, &quot;]&quot;, &quot;(&quot;, &quot;)&quot;, &quot;&lt;-&quot;, &quot;,&quot;]; const symbolsSorted = [...operators, ...symbols].sort((a, b) =&gt; b.length - a.length) for (const sym of symbolsSorted) { if (remainder.startsWith(sym)) return { newRemainder: remainder.slice(sym.length), token: { type: sym } }; } I have to check longer symbols first, because &lt;- starts with both &lt; and &lt;-, but we want it to say it’s &lt;- (the assignment arrow), and not a less than sign. This is how I make the firstToken function. If we want all the tokens, I made a simple function that gets them all. It also keeps track of the location in the code: export function tokenize(code: string): (Token &amp; { location: Location })[] { let remainder = code; let result = []; let location = { line: 1, col: 1 }; while (!remainder.match(/^\\s*$/)) { const { text, token, whitespace } = firstToken(remainder); remainder = remainder.slice(text.length + whitespace.length); for (const c of whitespace) { if (c === &quot;\\n&quot;) { location.col = 1; location.line++; } else { location.col++; } } for (const c of text) { if (c === &quot;\\n&quot;) { location.col = 1; location.line++; } else { location.col++; } } result.push({ ...token, location }); } return result; }","headline":"Tokenizer","dateModified":"2021-08-09T00:00:00-04:00","datePublished":"2021-08-09T00:00:00-04:00","url":"/darby-capstone-blog/2021/08/09/tokenizer.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
</head>
<body>
  <header class="texture-red">
    <div class="container"><div class="navbar">
	<ul>
		
		<a href="/"><li  >About</li></a>
		
		<a href="/expectations"><li  >Expectations</li></a>
		
		<a href="/experience"><li  >Experience</li></a>
		
		<a href="/mentor"><li  >Mentor</li></a>
		
		<a href="/interview"><li  >Interview</li></a>
		
		<a href="/reflection"><li  >Reflection</li></a>
		
		<a href="https://jsims.org/apcsp"><li  >Run my Project</li></a>
		
	</ul>
</div></div><div class="container">
	<h1>Tokenizer</h1>
	<h4 class="post-description"></h4>
	<div class="post-date" style="margin-top:20px">
		Published on Aug 9, 2021
	</div>
	<ul class="post-tags"></ul>
</div>
</header>
  <main>
    <div class="container">
      <div class="post-container">
          <p>I want to parse my expressions into an AST, but first it is good to make a “tokenizer”.</p>

<p>When you are parsing, it is a lot easier to say “there should be a number here”, without worrying about the individual digits and characters that make up the number. So we turn it into tokens, like <code class="language-plaintext highlighter-rouge">number</code> or <code class="language-plaintext highlighter-rouge">+</code> or <code class="language-plaintext highlighter-rouge">variable</code>.</p>

<p>For example, for the expression <code class="language-plaintext highlighter-rouge">(myvariable + 1) * 50</code>, which is really a sequence of characters like</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="dl">'</span><span class="s1">(</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">m</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">y</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">v</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">r</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">i</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">l</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">e</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">+</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">)</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">*</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1"> </span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">5</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">0</span><span class="dl">'</span><span class="p">]</span>
</code></pre></div></div>

<p>The tokenizer will turn it into</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
    <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">(</span><span class="dl">'</span> <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">variable</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">myvariable</span><span class="dl">'</span>
    <span class="p">},</span>
    <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">+</span><span class="dl">'</span> <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">value</span><span class="p">:</span> <span class="mi">1</span>
    <span class="p">},</span>
    <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">)</span><span class="dl">'</span> <span class="p">},</span>
    <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">*</span><span class="dl">'</span> <span class="p">},</span>
    <span class="p">{</span>
        <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">value</span><span class="p">:</span> <span class="mi">50</span>
    <span class="p">}</span>
<span class="p">]</span>
</code></pre></div></div>

<p>Notice that this does not include any nested structure like our AST. It is still a sequence of things. However, the whitespace is gone, and things that are one “token” like an individual variable or number are together. The parser would then use these tokens to turn it into</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="nl">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">operator</span><span class="dl">"</span><span class="p">,</span>
    <span class="nx">operator</span><span class="p">:</span> <span class="dl">"</span><span class="s2">*</span><span class="dl">"</span><span class="p">,</span>
    <span class="nx">lhs</span><span class="p">:</span> <span class="p">{</span>
        <span class="nl">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">operator</span><span class="dl">"</span><span class="p">,</span>
        <span class="nx">operator</span><span class="p">:</span> <span class="dl">"</span><span class="s2">+</span><span class="dl">"</span>
        <span class="nx">lhs</span><span class="p">:</span> <span class="p">{</span>
            <span class="nl">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">variable</span><span class="dl">"</span><span class="p">,</span>
            <span class="nx">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">myvariable</span><span class="dl">"</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="nx">rhs</span><span class="p">:</span> <span class="p">{</span>
            <span class="nl">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">,</span>
            <span class="nx">value</span><span class="p">:</span> <span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="nx">rhs</span><span class="p">:</span> <span class="p">{</span>
        <span class="nl">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">,</span>
        <span class="nx">value</span><span class="p">:</span> <span class="mi">50</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The technique I will use to create the tokenizer is regular expressions. These are things which match certain strings. The regex <code class="language-plaintext highlighter-rouge">/^\s+/</code> is pretty simple, it matches some amount of whitespace (for us to skip).
<code class="language-plaintext highlighter-rouge">/^[a-zA-Z_][a-zA-Z_0-9]*/</code> matches identifiers (variable names), which must start with a letter or underscore, then have some amount of letters, underscores, or digits (the <code class="language-plaintext highlighter-rouge">*</code> means 0 or more, <code class="language-plaintext highlighter-rouge">+</code> means 1 or more.)
<code class="language-plaintext highlighter-rouge">/^[0-9]*\.?[0-9]+/</code> is complicated, but it matches numbers. These can have possibly some digits, maybe a decimal point, and must always end with 1 or more digit. This lets us have all sorts of numbers, like .5, 6.3, and 12.</p>

<p>We need the <code class="language-plaintext highlighter-rouge">^</code> at the beginning because that means it match match at the start of the string. We don’t want our regex to be finding things that happen later on than we are looking.</p>

<p>The tokenizer keeps checking if the code matches any of these regular expressions, or if it matches a symbol. I check for symbols kind of like this:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">operators</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">+</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">-</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">*</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">/</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">MOD</span><span class="dl">"</span>
    <span class="p">,</span> <span class="dl">"</span><span class="s2">=</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">!=</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">&gt;</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">&lt;</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">&gt;=</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">&lt;=</span><span class="dl">"</span>
    <span class="p">,</span> <span class="dl">"</span><span class="s2">AND</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">OR</span><span class="dl">"</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">symbols</span> <span class="o">=</span> <span class="p">[</span><span class="dl">"</span><span class="s2">{</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">}</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">[</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">]</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">(</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">)</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">&lt;-</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">,</span><span class="dl">"</span><span class="p">];</span>
<span class="kd">const</span> <span class="nx">symbolsSorted</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">operators</span><span class="p">,</span> <span class="p">...</span><span class="nx">symbols</span><span class="p">].</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">b</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="nx">a</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">sym</span> <span class="k">of</span> <span class="nx">symbolsSorted</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">remainder</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="nx">sym</span><span class="p">))</span> <span class="k">return</span> <span class="p">{</span> <span class="na">newRemainder</span><span class="p">:</span> <span class="nx">remainder</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">sym</span><span class="p">.</span><span class="nx">length</span><span class="p">),</span> <span class="na">token</span><span class="p">:</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="nx">sym</span> <span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I have to check longer symbols first, because <code class="language-plaintext highlighter-rouge">&lt;-</code> starts with both <code class="language-plaintext highlighter-rouge">&lt;</code> and <code class="language-plaintext highlighter-rouge">&lt;-</code>, but we want it to say it’s <code class="language-plaintext highlighter-rouge">&lt;-</code> (the assignment arrow), and not a less than sign.</p>

<p>This is how I make the <code class="language-plaintext highlighter-rouge">firstToken</code> function. If we want all the tokens, I made a simple function that gets them all. It also keeps track of the location in the code:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">function</span> <span class="nx">tokenize</span><span class="p">(</span><span class="nx">code</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="p">(</span><span class="nx">Token</span> <span class="o">&amp;</span> <span class="p">{</span> <span class="na">location</span><span class="p">:</span> <span class="nx">Location</span> <span class="p">})[]</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">remainder</span> <span class="o">=</span> <span class="nx">code</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="kd">let</span> <span class="nx">location</span> <span class="o">=</span> <span class="p">{</span> <span class="na">line</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">col</span><span class="p">:</span> <span class="mi">1</span> <span class="p">};</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">remainder</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/^</span><span class="se">\s</span><span class="sr">*$/</span><span class="p">))</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="p">{</span> <span class="nx">text</span><span class="p">,</span> <span class="nx">token</span><span class="p">,</span> <span class="nx">whitespace</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">firstToken</span><span class="p">(</span><span class="nx">remainder</span><span class="p">);</span>
        <span class="nx">remainder</span> <span class="o">=</span> <span class="nx">remainder</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">text</span><span class="p">.</span><span class="nx">length</span> <span class="o">+</span> <span class="nx">whitespace</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">c</span> <span class="k">of</span> <span class="nx">whitespace</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">c</span> <span class="o">===</span> <span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span> <span class="nx">location</span><span class="p">.</span><span class="nx">col</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">location</span><span class="p">.</span><span class="nx">line</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nx">location</span><span class="p">.</span><span class="nx">col</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">c</span> <span class="k">of</span> <span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">c</span> <span class="o">===</span> <span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span> <span class="nx">location</span><span class="p">.</span><span class="nx">col</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">location</span><span class="p">.</span><span class="nx">line</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="nx">location</span><span class="p">.</span><span class="nx">col</span><span class="o">++</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="p">...</span><span class="nx">token</span><span class="p">,</span> <span class="nx">location</span> <span class="p">});</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

      </div>

        <!-- Configure Disqus --></div>
  </main></body>
</html>