<!DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link href="https://fonts.googleapis.com/css?family=Nunito+Sans:400,400i,700&display=swap" rel="stylesheet">
<link rel="stylesheet" href="/darby-capstone-blog/assets/css/style.css">
<title>Evaluating Basic Expressions</title>
<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Evaluating Basic Expressions</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Evaluating Basic Expressions" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Now that we can parse, we have to run the code. I made a class Interpreter that will hold the state. Right now it just has variables: export class Interpreter { globals: Map&lt;string, Value&gt;; } Of course, a value is one of these: export type Value = | { type: &quot;number&quot;, value: number } | { type: &quot;string&quot;, value: string } | { type: &quot;boolean&quot;, value: boolean } | { type: &quot;list&quot;, value: Value[] } So the idea is that we will have functions for running and evaluating different things. So to run a block, it’s pretty simple: async runBlock(block: Statement[]): Promise&lt;void&gt; { for (let stat of block) { this.run(stat); } } All of these functions are async because we will have to do things like get input, or step through code, and will need to wait for things to happen. Then we just do different things based on the kind of statement: async assign(ast: AssignableExpression&lt;Annotations&gt;, value: Value) { if (ast.type === &quot;variable&quot;) { this.globals.set(ast.name, cloneDeep(value)); } else { const index = (await this.expectType(ast.index, &quot;number&quot;)).value; const list = (await this.expectType(ast.list, &quot;list&quot;)).value; if (!Number.isInteger(index)) this.error(ast.index, &quot;must be an integer&quot;); if (index &lt;= 0) this.error(ast.index, &quot;must be &gt;= 1&quot;); if (index &gt; list.length) this.error(ast, &quot;index bigger than list length&quot;); list[index - 1] = value; } } async run(ast: Statement): Promise&lt;void&gt; { if (ast.type === &quot;assign&quot;) { const value = await this.evaluate(ast.rhs); await this.assign(ast.lhs, value); } /* ... */ else if (ast.type === &quot;ifelse&quot;) { const condition = (await this.expectType(ast.condition, &quot;boolean&quot;)).value; ast.condition.evaluated = { type: &quot;boolean&quot;, value: condition }; if (condition) { this.runBlock(ast.iftrue); } else { this.runBlock(ast.iffalse); } /* ... */ } I have some helper functions this.error, which throws an error, and this.expectType, which evaluates something and throws an error if it’s the wrong type. This makes my code a lot simpler. For evaluating expressions, it’s pretty much the same, except we return a Value. Some of them are short and simple: /* ... */ else if (ast.type === &quot;negate&quot;) { const num = this.expectType(ast.value, &quot;number&quot;); return { type: &quot;number&quot;, value: -num }; } else if (ast.type === &quot;variable&quot;) { const value = this.globals.get(ast.name); if (value === undefined) { this.error(ast, &quot;unknown name&quot;); } return value; } And others are longer. For operator, I hade to write code to handle every different operator: if (ast.type === &quot;operator&quot;) { if (ast.operator === &quot;!=&quot; || ast.operator === &quot;=&quot;) { const lhs = await this.evaluate(ast.lhs); const rhs = await this.evaluate(ast.rhs); const equals = isequal(lhs, rhs); const result = ast.operator === &quot;!=&quot; ? !equals : equals; return { type: &quot;boolean&quot;, value: result }; } else if (ast.operator === &quot;*&quot; || ast.operator === &quot;+&quot; || ast.operator === &quot;-&quot; || ast.operator === &quot;/&quot; || ast.operator === &quot;MOD&quot;) { const a = (await this.expectType(ast.lhs, &quot;number&quot;)).value; const b = (await (this.expectType(ast.rhs, &quot;number&quot;))).value; const value = ast.operator === &quot;*&quot; ? a * b : ast.operator === &quot;+&quot; ? a + b : ast.operator === &quot;-&quot; ? a - b : ast.operator === &quot;/&quot; ? a / b : a % b; return { type: &quot;number&quot;, value } } /* ... */ } It was pretty long, but not too hard. And we can now run some basic code. But it’s hard to try it out, since we can’t DISPLAY anything." />
<meta property="og:description" content="Now that we can parse, we have to run the code. I made a class Interpreter that will hold the state. Right now it just has variables: export class Interpreter { globals: Map&lt;string, Value&gt;; } Of course, a value is one of these: export type Value = | { type: &quot;number&quot;, value: number } | { type: &quot;string&quot;, value: string } | { type: &quot;boolean&quot;, value: boolean } | { type: &quot;list&quot;, value: Value[] } So the idea is that we will have functions for running and evaluating different things. So to run a block, it’s pretty simple: async runBlock(block: Statement[]): Promise&lt;void&gt; { for (let stat of block) { this.run(stat); } } All of these functions are async because we will have to do things like get input, or step through code, and will need to wait for things to happen. Then we just do different things based on the kind of statement: async assign(ast: AssignableExpression&lt;Annotations&gt;, value: Value) { if (ast.type === &quot;variable&quot;) { this.globals.set(ast.name, cloneDeep(value)); } else { const index = (await this.expectType(ast.index, &quot;number&quot;)).value; const list = (await this.expectType(ast.list, &quot;list&quot;)).value; if (!Number.isInteger(index)) this.error(ast.index, &quot;must be an integer&quot;); if (index &lt;= 0) this.error(ast.index, &quot;must be &gt;= 1&quot;); if (index &gt; list.length) this.error(ast, &quot;index bigger than list length&quot;); list[index - 1] = value; } } async run(ast: Statement): Promise&lt;void&gt; { if (ast.type === &quot;assign&quot;) { const value = await this.evaluate(ast.rhs); await this.assign(ast.lhs, value); } /* ... */ else if (ast.type === &quot;ifelse&quot;) { const condition = (await this.expectType(ast.condition, &quot;boolean&quot;)).value; ast.condition.evaluated = { type: &quot;boolean&quot;, value: condition }; if (condition) { this.runBlock(ast.iftrue); } else { this.runBlock(ast.iffalse); } /* ... */ } I have some helper functions this.error, which throws an error, and this.expectType, which evaluates something and throws an error if it’s the wrong type. This makes my code a lot simpler. For evaluating expressions, it’s pretty much the same, except we return a Value. Some of them are short and simple: /* ... */ else if (ast.type === &quot;negate&quot;) { const num = this.expectType(ast.value, &quot;number&quot;); return { type: &quot;number&quot;, value: -num }; } else if (ast.type === &quot;variable&quot;) { const value = this.globals.get(ast.name); if (value === undefined) { this.error(ast, &quot;unknown name&quot;); } return value; } And others are longer. For operator, I hade to write code to handle every different operator: if (ast.type === &quot;operator&quot;) { if (ast.operator === &quot;!=&quot; || ast.operator === &quot;=&quot;) { const lhs = await this.evaluate(ast.lhs); const rhs = await this.evaluate(ast.rhs); const equals = isequal(lhs, rhs); const result = ast.operator === &quot;!=&quot; ? !equals : equals; return { type: &quot;boolean&quot;, value: result }; } else if (ast.operator === &quot;*&quot; || ast.operator === &quot;+&quot; || ast.operator === &quot;-&quot; || ast.operator === &quot;/&quot; || ast.operator === &quot;MOD&quot;) { const a = (await this.expectType(ast.lhs, &quot;number&quot;)).value; const b = (await (this.expectType(ast.rhs, &quot;number&quot;))).value; const value = ast.operator === &quot;*&quot; ? a * b : ast.operator === &quot;+&quot; ? a + b : ast.operator === &quot;-&quot; ? a - b : ast.operator === &quot;/&quot; ? a / b : a % b; return { type: &quot;number&quot;, value } } /* ... */ } It was pretty long, but not too hard. And we can now run some basic code. But it’s hard to try it out, since we can’t DISPLAY anything." />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-08-17T00:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Evaluating Basic Expressions" />
<script type="application/ld+json">
{"mainEntityOfPage":{"@type":"WebPage","@id":"/darby-capstone-blog/2021/08/17/evaluating-basic-expressions.html"},"@type":"BlogPosting","description":"Now that we can parse, we have to run the code. I made a class Interpreter that will hold the state. Right now it just has variables: export class Interpreter { globals: Map&lt;string, Value&gt;; } Of course, a value is one of these: export type Value = | { type: &quot;number&quot;, value: number } | { type: &quot;string&quot;, value: string } | { type: &quot;boolean&quot;, value: boolean } | { type: &quot;list&quot;, value: Value[] } So the idea is that we will have functions for running and evaluating different things. So to run a block, it’s pretty simple: async runBlock(block: Statement[]): Promise&lt;void&gt; { for (let stat of block) { this.run(stat); } } All of these functions are async because we will have to do things like get input, or step through code, and will need to wait for things to happen. Then we just do different things based on the kind of statement: async assign(ast: AssignableExpression&lt;Annotations&gt;, value: Value) { if (ast.type === &quot;variable&quot;) { this.globals.set(ast.name, cloneDeep(value)); } else { const index = (await this.expectType(ast.index, &quot;number&quot;)).value; const list = (await this.expectType(ast.list, &quot;list&quot;)).value; if (!Number.isInteger(index)) this.error(ast.index, &quot;must be an integer&quot;); if (index &lt;= 0) this.error(ast.index, &quot;must be &gt;= 1&quot;); if (index &gt; list.length) this.error(ast, &quot;index bigger than list length&quot;); list[index - 1] = value; } } async run(ast: Statement): Promise&lt;void&gt; { if (ast.type === &quot;assign&quot;) { const value = await this.evaluate(ast.rhs); await this.assign(ast.lhs, value); } /* ... */ else if (ast.type === &quot;ifelse&quot;) { const condition = (await this.expectType(ast.condition, &quot;boolean&quot;)).value; ast.condition.evaluated = { type: &quot;boolean&quot;, value: condition }; if (condition) { this.runBlock(ast.iftrue); } else { this.runBlock(ast.iffalse); } /* ... */ } I have some helper functions this.error, which throws an error, and this.expectType, which evaluates something and throws an error if it’s the wrong type. This makes my code a lot simpler. For evaluating expressions, it’s pretty much the same, except we return a Value. Some of them are short and simple: /* ... */ else if (ast.type === &quot;negate&quot;) { const num = this.expectType(ast.value, &quot;number&quot;); return { type: &quot;number&quot;, value: -num }; } else if (ast.type === &quot;variable&quot;) { const value = this.globals.get(ast.name); if (value === undefined) { this.error(ast, &quot;unknown name&quot;); } return value; } And others are longer. For operator, I hade to write code to handle every different operator: if (ast.type === &quot;operator&quot;) { if (ast.operator === &quot;!=&quot; || ast.operator === &quot;=&quot;) { const lhs = await this.evaluate(ast.lhs); const rhs = await this.evaluate(ast.rhs); const equals = isequal(lhs, rhs); const result = ast.operator === &quot;!=&quot; ? !equals : equals; return { type: &quot;boolean&quot;, value: result }; } else if (ast.operator === &quot;*&quot; || ast.operator === &quot;+&quot; || ast.operator === &quot;-&quot; || ast.operator === &quot;/&quot; || ast.operator === &quot;MOD&quot;) { const a = (await this.expectType(ast.lhs, &quot;number&quot;)).value; const b = (await (this.expectType(ast.rhs, &quot;number&quot;))).value; const value = ast.operator === &quot;*&quot; ? a * b : ast.operator === &quot;+&quot; ? a + b : ast.operator === &quot;-&quot; ? a - b : ast.operator === &quot;/&quot; ? a / b : a % b; return { type: &quot;number&quot;, value } } /* ... */ } It was pretty long, but not too hard. And we can now run some basic code. But it’s hard to try it out, since we can’t DISPLAY anything.","headline":"Evaluating Basic Expressions","dateModified":"2021-08-17T00:00:00-04:00","datePublished":"2021-08-17T00:00:00-04:00","url":"/darby-capstone-blog/2021/08/17/evaluating-basic-expressions.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
</head>
<body>
  <header class="texture-red">
    <div class="container"><div class="navbar">
	<ul>
		
		<a href="/"><li  >About</li></a>
		
		<a href="/expectations"><li  >Expectations</li></a>
		
		<a href="/experience"><li  >Experience</li></a>
		
		<a href="/mentor"><li  >Mentor</li></a>
		
		<a href="/interview"><li  >Interview</li></a>
		
		<a href="/reflection"><li  >Reflection</li></a>
		
		<a href="https://jsims.org/apcsp"><li  >Run my Project</li></a>
		
	</ul>
</div></div><div class="container">
	<h1>Evaluating Basic Expressions</h1>
	<h4 class="post-description"></h4>
	<div class="post-date" style="margin-top:20px">
		Published on Aug 17, 2021
	</div>
	<ul class="post-tags"></ul>
</div>
</header>
  <main>
    <div class="container">
      <div class="post-container">
          <p>Now that we can parse, we have to run the code.</p>

<p>I made a class <code class="language-plaintext highlighter-rouge">Interpreter</code> that will hold the state. Right now it just has variables:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">class</span> <span class="nx">Interpreter</span> <span class="p">{</span>
    <span class="nl">globals</span><span class="p">:</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">,</span> <span class="nx">Value</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Of course, a value is one of these:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">type</span> <span class="nx">Value</span> <span class="o">=</span>
    <span class="o">|</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="kr">number</span> <span class="p">}</span>
    <span class="o">|</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="kr">string</span> <span class="p">}</span>
    <span class="o">|</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">boolean</span><span class="dl">"</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">boolean</span> <span class="p">}</span>
    <span class="o">|</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">list</span><span class="dl">"</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">Value</span><span class="p">[]</span> <span class="p">}</span>
</code></pre></div></div>

<p>So the idea is that we will have functions for running and evaluating different things. So to run a block, it’s pretty simple:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="nx">runBlock</span><span class="p">(</span><span class="nx">block</span><span class="p">:</span> <span class="nx">Statement</span><span class="p">[]):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">stat</span> <span class="k">of</span> <span class="nx">block</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">run</span><span class="p">(</span><span class="nx">stat</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>All of these functions are async because we will have to do things like get input, or step through code, and will need to wait for things to happen.</p>

<p>Then we just do different things based on the kind of statement:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">async</span> <span class="nx">assign</span><span class="p">(</span><span class="nx">ast</span><span class="p">:</span> <span class="nx">AssignableExpression</span><span class="o">&lt;</span><span class="nx">Annotations</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">value</span><span class="p">:</span> <span class="nx">Value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">variable</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">globals</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="nx">cloneDeep</span><span class="p">(</span><span class="nx">value</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">index</span> <span class="o">=</span> <span class="p">(</span><span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">expectType</span><span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">index</span><span class="p">,</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">)).</span><span class="nx">value</span><span class="p">;</span>

        <span class="kd">const</span> <span class="nx">list</span> <span class="o">=</span> <span class="p">(</span><span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">expectType</span><span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">list</span><span class="p">,</span> <span class="dl">"</span><span class="s2">list</span><span class="dl">"</span><span class="p">)).</span><span class="nx">value</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">Number</span><span class="p">.</span><span class="nx">isInteger</span><span class="p">(</span><span class="nx">index</span><span class="p">))</span> <span class="k">this</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">index</span><span class="p">,</span> <span class="dl">"</span><span class="s2">must be an integer</span><span class="dl">"</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">index</span><span class="p">,</span> <span class="dl">"</span><span class="s2">must be &gt;= 1</span><span class="dl">"</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">&gt;</span> <span class="nx">list</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">ast</span><span class="p">,</span> <span class="dl">"</span><span class="s2">index bigger than list length</span><span class="dl">"</span><span class="p">);</span>

        <span class="nx">list</span><span class="p">[</span><span class="nx">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
        
<span class="k">async</span> <span class="nx">run</span><span class="p">(</span><span class="nx">ast</span><span class="p">:</span> <span class="nx">Statement</span><span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">assign</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">evaluate</span><span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">rhs</span><span class="p">);</span>
        <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">lhs</span><span class="p">,</span> <span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span> 
    <span class="cm">/* ... */</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">ifelse</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">condition</span> <span class="o">=</span> <span class="p">(</span><span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">expectType</span><span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">condition</span><span class="p">,</span> <span class="dl">"</span><span class="s2">boolean</span><span class="dl">"</span><span class="p">)).</span><span class="nx">value</span><span class="p">;</span>
        <span class="nx">ast</span><span class="p">.</span><span class="nx">condition</span><span class="p">.</span><span class="nx">evaluated</span> <span class="o">=</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">boolean</span><span class="dl">"</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">condition</span> <span class="p">};</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">condition</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">runBlock</span><span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">iftrue</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">runBlock</span><span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">iffalse</span><span class="p">);</span>
        <span class="p">}</span>
    
    <span class="cm">/* ... */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I have some helper functions <code class="language-plaintext highlighter-rouge">this.error</code>, which throws an error, and <code class="language-plaintext highlighter-rouge">this.expectType</code>, which evaluates something and throws an error if it’s the wrong type. This makes my code a lot simpler.</p>

<p>For evaluating expressions, it’s pretty much the same, except we return a <code class="language-plaintext highlighter-rouge">Value</code>.</p>

<p>Some of them are short and simple:</p>
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* ... */</span>
<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">negate</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">num</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">expectType</span><span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">value</span><span class="p">,</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="o">-</span><span class="nx">num</span> <span class="p">};</span>
<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">variable</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">globals</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">===</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">ast</span><span class="p">,</span> <span class="dl">"</span><span class="s2">unknown name</span><span class="dl">"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">value</span><span class="p">;</span>
<span class="p">}</span> 
</code></pre></div></div>

<p>And others are longer. For <code class="language-plaintext highlighter-rouge">operator</code>, I hade to write code to handle every different operator:</p>
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">operator</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">operator</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">!=</span><span class="dl">"</span> <span class="o">||</span> <span class="nx">ast</span><span class="p">.</span><span class="nx">operator</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">=</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">lhs</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">evaluate</span><span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">lhs</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">rhs</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">evaluate</span><span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">rhs</span><span class="p">);</span>
        <span class="kd">const</span> <span class="nx">equals</span> <span class="o">=</span> <span class="nx">isequal</span><span class="p">(</span><span class="nx">lhs</span><span class="p">,</span> <span class="nx">rhs</span><span class="p">);</span>

        <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">ast</span><span class="p">.</span><span class="nx">operator</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">!=</span><span class="dl">"</span> <span class="p">?</span> <span class="o">!</span><span class="nx">equals</span> <span class="p">:</span> <span class="nx">equals</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">boolean</span><span class="dl">"</span><span class="p">,</span> <span class="na">value</span><span class="p">:</span> <span class="nx">result</span> <span class="p">};</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">operator</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">*</span><span class="dl">"</span> <span class="o">||</span> <span class="nx">ast</span><span class="p">.</span><span class="nx">operator</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">+</span><span class="dl">"</span> <span class="o">||</span>
        <span class="nx">ast</span><span class="p">.</span><span class="nx">operator</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">-</span><span class="dl">"</span> <span class="o">||</span> <span class="nx">ast</span><span class="p">.</span><span class="nx">operator</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">/</span><span class="dl">"</span> <span class="o">||</span> <span class="nx">ast</span><span class="p">.</span><span class="nx">operator</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">MOD</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">(</span><span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">expectType</span><span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">lhs</span><span class="p">,</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">)).</span><span class="nx">value</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">(</span><span class="k">await</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">expectType</span><span class="p">(</span><span class="nx">ast</span><span class="p">.</span><span class="nx">rhs</span><span class="p">,</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">))).</span><span class="nx">value</span><span class="p">;</span>
        <span class="kd">const</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">ast</span><span class="p">.</span><span class="nx">operator</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">*</span><span class="dl">"</span> <span class="p">?</span> <span class="nx">a</span> <span class="o">*</span> <span class="nx">b</span>
            <span class="p">:</span> <span class="nx">ast</span><span class="p">.</span><span class="nx">operator</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">+</span><span class="dl">"</span> <span class="p">?</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
                <span class="p">:</span> <span class="nx">ast</span><span class="p">.</span><span class="nx">operator</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">-</span><span class="dl">"</span> <span class="p">?</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span>
                    <span class="p">:</span> <span class="nx">ast</span><span class="p">.</span><span class="nx">operator</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">/</span><span class="dl">"</span> <span class="p">?</span> <span class="nx">a</span> <span class="o">/</span> <span class="nx">b</span> <span class="p">:</span>
                        <span class="nx">a</span> <span class="o">%</span> <span class="nx">b</span><span class="p">;</span>
        <span class="k">return</span> <span class="p">{</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">,</span> <span class="nx">value</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="cm">/* ... */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It was pretty long, but not too hard. And we can now run some basic code. But it’s hard to try it out, since we can’t <code class="language-plaintext highlighter-rouge">DISPLAY</code> anything.</p>

      </div>

        <!-- Configure Disqus --></div>
  </main></body>
</html>